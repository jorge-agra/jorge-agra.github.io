{"version":3,"file":"UNSAFE_TagCloud.js","sources":["../../src/UNSAFE_TagCloud/TagCloudUtils.ts","../../src/UNSAFE_TagCloud/TagCloudItem.tsx","../../src/UNSAFE_TagCloud/TagCloudNavUtils.ts","../../src/UNSAFE_TagCloud/useTagCloudDatatip.ts","../../src/UNSAFE_TagCloud/TagCloud.tsx","../../src/UNSAFE_TagCloud/useEvents.tsx"],"sourcesContent":["import { ItemInfo, TagCloudItemProps } from './TagCloud.type';\nimport { _lightenColor, getContrastingTextColor } from '../utils/PRIVATE_visColorUtils/ColorUtils';\nimport { getUnion, intersects } from '../utils/PRIVATE_visLayoutUtils/LayoutUtils';\nimport { HTMLAttributesSignalExcluded } from '../utils/UNSAFE_attributeUtils';\nimport { BundleType } from '../resources/nls/bundle';\nimport { TagItemProps } from './TagCloudItem';\nimport { Font, TextDimensions } from '../hooks/PRIVATE_useTextDimensions';\n\nconst HOVER_OPACITY = 0.35;\nconst HOVER_SELECTED_OPACITY = 0.65;\nconst BOTTOM_PADDING = 20;\nconst DEFAULT_FONT_SIZE = 12;\n\n/**\n * helper layout functions for font size calc\n * @param {number} minValue\n * @param {number} maxValue\n * @param {number} range\n * @return {number}\n */\nexport const fontSizeCalc = (value: number, minValue: number, maxValue: number, range: number) => {\n  return minValue === maxValue\n    ? DEFAULT_FONT_SIZE\n    : DEFAULT_FONT_SIZE +\n        Math.ceil((((range - 1) * (value - minValue)) / (maxValue - minValue)) * DEFAULT_FONT_SIZE);\n};\n\n/**\n * returns initial font size arr of items for layout\n * @param {Array} items\n * @return {Array}\n */\nexport function getInitialFontSize<K>(items: TagCloudItemProps<K>[]): TagItemProps<K>[] {\n  const fontSizeArr = [];\n  let minValue = Number.MAX_VALUE;\n  let maxValue = -Number.MAX_VALUE;\n  // First iterate thru data items to find the min and max values\n  for (let i = 0; i < items.length; i++) {\n    minValue = Math.min(minValue, items[i].value);\n    maxValue = Math.max(maxValue, items[i].value);\n  }\n\n  for (let i = 0; i < items.length; i++) {\n    const x = fontSizeCalc(items[i].value, minValue, maxValue, 3);\n    fontSizeArr.push({ ...items[i], fontSize: x });\n  }\n  return fontSizeArr;\n}\n\n/**\n * Calculates the line breaks for rectangular layout\n * @param {Array} arDims an array of dvt.Dimension objects for each tag\n * @param {number} width the available width\n * @return {Array} an array containing the starting tag index for each line in the layout\n * @private\n */\nexport function calculateLineBreaks(arDims: any, width: any) {\n  const hPadding = 2;\n  const lines = [0];\n  let curWidth = arDims[0].w + hPadding;\n  if (arDims.length > 1) {\n    for (let i = 1; i < arDims.length; i++) {\n      if (curWidth + arDims[i].w > width) {\n        lines.push(i);\n        curWidth = 0;\n      }\n      curWidth += arDims[i].w + hPadding;\n    }\n  }\n  return lines;\n}\n\n/**\n * Returns the items position and font size in cloud layout.\n * @param items\n * @param tagcloudH\n * @param tagcloudW\n */\nexport function getCloudLayout<K>(\n  items: TagCloudItemProps<K>[],\n  tagcloudW: number,\n  tagcloudH: number,\n  isRTL: boolean,\n  getTextDimensions: (textString: string, font: Font) => TextDimensions\n): TagItemProps<K>[] {\n  const positions: any[] = [];\n  const steps = 180;\n  let xrStep = 10 / steps;\n  let yrStep = 10 / steps;\n  if (tagcloudW > tagcloudH) xrStep *= tagcloudW / tagcloudH;\n  else yrStep *= tagcloudH / tagcloudW;\n  const thetaStep = (2 * Math.PI) / steps;\n  let bounds = null;\n  let maxFontSize = 0;\n  const cosCache = [];\n  const sinCache = [];\n  const tagWordData = [];\n  const tagCloudX = 0; // availSpace.x\n  const tagCloudY = 0; // availSpace.y\n\n  const initialFontItems = getInitialFontSize(items);\n\n  for (let i = 0; i < initialFontItems.length; i++) {\n    let placed = false;\n    let step = 0;\n    let stepIncrement = 4;\n    const tag = initialFontItems[i];\n    const tagDimensions = getTextDimensions(tag.label, {\n      fontSize: tag.fontSize + 'px'\n    });\n    maxFontSize = Math.max(maxFontSize, tag.fontSize);\n    let lastCollisionIndex = -1;\n    while (!placed) {\n      // cache sin/cos values because Chrome is slow at these calculations\n      const lookup = step % steps;\n      if (cosCache[lookup] === undefined) cosCache[lookup] = Math.cos(step * thetaStep);\n      if (sinCache[lookup] === undefined) sinCache[lookup] = Math.sin(step * thetaStep);\n      const _x = xrStep * step * cosCache[lookup];\n      const _y = yrStep * step * sinCache[lookup];\n      const tagCloudDiv = { x: _x, y: _y, w: tagDimensions.width, h: tagDimensions.height }; // this needs to change\n      placed = true;\n      if (lastCollisionIndex !== -1) {\n        if (intersects(positions[lastCollisionIndex], tagCloudDiv)) {\n          placed = false;\n        }\n      }\n\n      if (placed) {\n        for (let j = 0; j < i; j++) {\n          if (intersects(positions[j], tagCloudDiv)) {\n            lastCollisionIndex = j;\n            placed = false;\n            break;\n          }\n        }\n      }\n\n      if (placed) {\n        if (!bounds) {\n          bounds = tagCloudDiv;\n        } else {\n          bounds = getUnion(bounds, tagCloudDiv);\n        }\n        lastCollisionIndex = -1;\n        positions[i] = tagCloudDiv;\n        tag.x = _x; // tag.setX(x)\n        tag.y = _y; // tag.setY(-tagCloudDiv.y + y);\n        tag.w = tagDimensions.width;\n        tag.h = tagDimensions.height;\n      }\n      // Adjust stepIncrement so we check smaller degrees as spiral loops out\n      if (step == 3600) {\n        // 20 loops\n        stepIncrement = 3;\n      } else if (step == 5400) {\n        // 30 loops\n        stepIncrement = 2;\n      } else if (step == 10800) {\n        // 60 loops\n        stepIncrement = 1;\n      }\n      step += stepIncrement;\n    }\n  }\n\n  if (bounds) {\n    const scale = Math.max(bounds.w / tagcloudW, bounds.h / tagcloudH);\n    const cx = bounds.x + bounds.w / 2;\n    const cy = bounds.y + bounds.h / 2;\n\n    for (let k = 0; k < initialFontItems.length; k++) {\n      let tagItemX;\n      const tagItem = initialFontItems[k];\n      if (!isRTL) {\n        tagItemX =\n          tagItem.x != null ? tagCloudX + tagItem.x / scale + (tagcloudW / 2 - cx / scale) : 0;\n      } else {\n        tagItemX =\n          tagItem.x != null ? tagCloudX - tagItem.x / scale - (tagcloudW / 2 - cx / scale) : 0;\n      }\n\n      const tagItemY =\n        tagItem.y != null ? tagCloudY + tagItem.y / scale + (tagcloudH / 2 - cy / scale) : 0;\n      const tagItemW = tagItem.w != null ? tagItem.w / scale : 0;\n      const tagItemH = tagItem.h != null ? tagItem.h / scale : 0;\n      const fontSize = tagItem.fontSize;\n      const tagItemFontSize = fontSize / scale;\n      tagWordData.push({\n        ...tagItem,\n        x: tagItemX,\n        y: tagItemY,\n        fontSize: tagItemFontSize,\n        w: tagItemW,\n        h: tagItemH\n      });\n    }\n  }\n  return tagWordData;\n}\n\n/**\n * Returns the items position and font size in rectangle layout.\n * @param items\n * @param hiddenIds\n * @param tagcloudH\n * @param tagcloudW\n */\nexport function getRectangleLayout<K>(\n  items: TagCloudItemProps<K>[],\n  tagcloudW: number,\n  tagcloudH: number,\n  isRTL: boolean,\n  getTextDimensions: (textString: string, font: Font) => TextDimensions\n) {\n  const tagWordData: any[] = [];\n  const arDims = [];\n  let maxWidth = 0;\n  let maxHeight = 0;\n  let maxFontSize = 0;\n  const vPadding = 2;\n  const margin = 0;\n  const tagCloudX = 0; // availSpace.x\n  const tagCloudY = 0; // availSpace.y\n\n  // initial items processing\n  const initialFontItems = getInitialFontSize(items);\n\n  // Get the unscaled dimensions\n  for (let i = 0; i < initialFontItems.length; i++) {\n    const tag = initialFontItems[i];\n    const tagDimensions = getTextDimensions(tag.label, {\n      fontSize: tag.fontSize + 'px'\n    });\n    maxWidth = Math.max(maxWidth, tagDimensions.width);\n    maxHeight = Math.max(maxHeight, tagDimensions.height);\n    maxFontSize = Math.max(maxFontSize, tag.fontSize);\n    arDims.push({ w: tagDimensions.width, h: tagDimensions.height });\n  }\n\n  // Iteratively calculate the ideal font scale\n  let minScale = 0;\n  let maxScale = (tagcloudW - 2 * margin) / maxWidth; // This is the max scale that can be applied before the longest word will no longer fit\n  let scale;\n  let arLines;\n  while (maxScale - minScale > 0.001) {\n    scale = (minScale + maxScale) / 2;\n    arLines = calculateLineBreaks(arDims, (tagcloudW - 2 * margin) / scale);\n    const h = arLines.length * (scale * maxHeight + vPadding) - vPadding;\n    if (h > tagcloudH - 2 * margin) {\n      maxScale = scale;\n    } else {\n      minScale = scale;\n    }\n  }\n\n  // Calculate final line breaks\n  scale = minScale;\n  arLines = calculateLineBreaks(arDims, (tagcloudW - 2 * margin) / scale);\n  arLines.push(initialFontItems.length);\n  for (let k = 0; k < arLines.length - 1; k++) {\n    const lineStart = arLines[k];\n    const lineEnd = arLines[k + 1];\n    let hPadding = 5;\n    let maxLineHeight = 0;\n    let justified = true;\n    if (lineEnd - lineStart > 1) {\n      let lineWidth = 0;\n      for (let j = lineStart; j < lineEnd; j++) {\n        lineWidth += arDims[j].w * scale;\n        maxLineHeight = Math.max(maxLineHeight, arDims[j].h * scale);\n      }\n      hPadding = (tagcloudW - 2 * margin - lineWidth) / (lineEnd - lineStart - 1);\n\n      if (k == arLines.length - 2) {\n        // Don't justify the last line unless flowing it with a gap of .5 * maxLineHeight fills more than\n        // 90% of the width\n        const flowPadding = 0.5 * maxLineHeight;\n        if (\n          flowPadding < hPadding &&\n          lineWidth + (lineEnd - lineStart) * flowPadding < 0.9 * (tagcloudW - 2 * margin)\n        ) {\n          hPadding = flowPadding;\n          justified = false;\n        }\n      }\n    }\n\n    const bottomY = margin + (k + 1) * (maxHeight * scale + vPadding) - vPadding;\n    let curX = margin;\n    for (let m = lineStart; m < lineEnd; m++) {\n      const tagLine = initialFontItems[m];\n      const fontSize = tagLine.fontSize;\n      const tagItemFontSize = fontSize * scale;\n      tagLine.fontSize = tagItemFontSize;\n      const tagDimensions = getTextDimensions(tagLine.label, {\n        fontSize: tagLine.fontSize + 'px'\n      });\n      tagLine.y = tagCloudY + bottomY + tagDimensions.y - BOTTOM_PADDING;\n      if (justified && m === lineEnd - 1 && m !== lineStart) {\n        if (!isRTL) tagLine.x = tagCloudX + tagcloudW - tagDimensions.width - margin;\n        else tagLine.x = tagCloudX + tagDimensions.width + margin - tagcloudW;\n        // alignRight(tagLine);\n      } else {\n        // alignLeft(tagLine);\n        tagLine.x = tagCloudX + curX;\n        if (!isRTL) {\n          curX += arDims[m].w * scale + hPadding;\n        } else {\n          // tagLine.alignRight();\n          curX -= arDims[m].w * scale + hPadding;\n        }\n      }\n      tagWordData.push({ ...tagLine, w: tagDimensions.width, h: tagDimensions.height });\n    }\n  }\n  return tagWordData;\n}\n\n/**\n * Calls the right layout algorithm based on tagcloud type.\n * @param layout cloud or rectangle. cloud if not defined.\n * @param items\n * @param hiddenIds\n * @param tagcloudH tagcloud height\n * @param tagcloudW tagcloud width\n */\nexport function getLayout<K>(\n  layout: string | undefined,\n  items: TagCloudItemProps<K>[],\n  tagcloudW: number,\n  tagcloudH: number,\n  isRTL: boolean,\n  getTextDimensions: (textString: string, font: Font) => TextDimensions\n) {\n  let layoutTagCloud: any[];\n  if (layout === 'cloud' || !layout) {\n    layoutTagCloud = getCloudLayout(items, tagcloudW, tagcloudH, isRTL, getTextDimensions);\n  } else {\n    layoutTagCloud = getRectangleLayout(items, tagcloudW, tagcloudH, isRTL, getTextDimensions);\n  }\n  return layoutTagCloud;\n}\n\n/**\n * Checks if the item is highlighted.\n * @param id Id of the item\n * @param highlighted The set of highlighted item\n */\nexport function isItemHighlighted<K>(id: K, highlightedIds?: K[]) {\n  if (!highlightedIds) {\n    return;\n  }\n  if (highlightedIds.length === 0) {\n    return true;\n  }\n  return new Set(highlightedIds).has(id);\n}\n\n/**\n * Checks if the item is highlighted.\n * @param id Id of the item\n * @param selectedIds The set of highlighted item\n */\nexport function isItemSelected<K>(id: K, selectedIds?: K[]) {\n  if (!selectedIds || selectedIds.length === 0) {\n    return false;\n  }\n  return new Set(selectedIds).has(id);\n}\n\n/**\n * Checks if the item is hidden.\n * @param id Id of the item.\n * @param hiddenIds The set of hidden items.\n * @returns\n */\nexport function isItemHidden<K>(id: K, hiddenIds?: K[]) {\n  if (!hiddenIds) {\n    return;\n  }\n  return new Set(hiddenIds).has(id);\n}\n\n/**\n * Returns the aria properties for the tag cloud.\n * @param isReadOnly { boolean } If the tag cloud is readonly.\n * @param accessibleLabel { string } The aria-label set by the app.\n * @returns The aria props.\n */\nexport function getAriaProps(\n  translations: BundleType,\n  hasData?: boolean,\n  accessibleLabel?: string\n): {\n  'aria-label': HTMLAttributesSignalExcluded['aria-label'];\n  role: HTMLAttributesSignalExcluded['role'];\n} {\n  return {\n    'aria-label': `${accessibleLabel || ''} ${\n      hasData ? '' : translations.dataVisualization_noData()\n    }`,\n    role: 'application'\n  };\n}\n\n/**\n * Returns the aria properties for the tag cloud.\n * @param isReadOnly { boolean } If the tag cloud is readonly.\n * @param accessibleLabel { string } The aria-label set by the app.\n * @returns The aria props.\n */\nexport function getItemAriaProps(\n  supportsSelection: boolean,\n  translations?: BundleType,\n  isSelected?: boolean,\n  accessibleLabel?: string\n): {\n  'aria-label': HTMLAttributesSignalExcluded['aria-label'];\n  role: HTMLAttributesSignalExcluded['role'];\n} {\n  const selectionAriaLabel = !supportsSelection\n    ? ''\n    : isSelected\n    ? translations?.dataVisualization_stateSelected()\n    : translations?.dataVisualization_stateUnselected();\n\n  return {\n    'aria-label': `${accessibleLabel || ''}. ${selectionAriaLabel}`,\n    role: 'img'\n  };\n}\n\n/**\n * Returns the item props for BaseTagCloudItem.\n * @param item The tagcloud item.\n * @param itemId The item index of the item.\n * @param focusedItem The info of currently focused item.\n * @param isReadOnly Whether the tagcloud is readonly.\n * @param hoveredItem The info of the currently hovered item.\n * @param hiddenIds The hidden ids.\n * @param highlightedIds The highlighted ids.\n */\nexport function getItemProps<K>(\n  item: TagCloudItemProps<K>,\n  itemIdx: number,\n  supportsSelection: boolean,\n  isReadOnly: boolean,\n  hoveredItem?: ItemInfo,\n  selectedIds?: Array<K>,\n  focusedItem?: ItemInfo,\n  highlightedIds?: Array<K>,\n  activeId?: string\n) {\n  let isCurrent = false;\n  let style;\n  if (!isReadOnly) {\n    const isFocusedItem = itemIdx === focusedItem?.idx;\n    const isHoveredItem = itemIdx === hoveredItem?.idx;\n    isCurrent = !!(\n      (isFocusedItem && focusedItem?.isCurrent) ||\n      (isHoveredItem && hoveredItem?.isCurrent)\n    );\n  }\n  const isHighlighted = isItemHighlighted(item.id, highlightedIds);\n  const isSelected = isItemSelected(item.id, selectedIds);\n\n  if (item.color) {\n    let color, backgroundColor, backgroundImage;\n\n    if (isSelected) {\n      backgroundColor = item.color;\n      // isCurrent ? hover selected : selected\n      color = getContrastingTextColor(\n        _lightenColor(backgroundColor, isCurrent ? HOVER_SELECTED_OPACITY : 1)\n      );\n      backgroundImage = isCurrent\n        ? `linear-gradient(rgba(255,255,255, ${1 - HOVER_SELECTED_OPACITY}), rgba(255,255,255, ${\n            1 - HOVER_SELECTED_OPACITY\n          }))`\n        : 'none';\n    } else if (isCurrent && supportsSelection) {\n      // hovered and selection supported\n      backgroundColor = item.color;\n      backgroundImage = `linear-gradient(rgba(255,255,255, ${\n        1 - HOVER_OPACITY\n      }), rgba(255,255,255, ${1 - HOVER_OPACITY}))`;\n      color = getContrastingTextColor(\n        _lightenColor(backgroundColor, isCurrent ? HOVER_OPACITY : 1)\n      );\n    } else {\n      color = item.color;\n    }\n\n    style = {\n      color,\n      backgroundColor,\n      backgroundImage\n    };\n  } else if (!supportsSelection) {\n    style = {\n      backgroundColor: 'none'\n    };\n  }\n\n  return {\n    isCurrent,\n    isHighlighted: isHighlighted,\n    isSelected: isSelected,\n    isFocused: focusedItem ? hasFocusRing(focusedItem, itemIdx) : false,\n    key: item.id,\n    itemIdx,\n    style,\n    activeId: isCurrent ? activeId : undefined,\n    isReadOnly,\n    ...item\n  };\n}\n\n/**\n * Returns the text for the tag cloud datatip.\n * @param items The tag cloud items data.\n * @param focusedItem The item currently keyboard focused.\n * @param hoveredItem The item that is currently hovered.\n * @param datatip The datatip.\n */\nexport function getDatatipText<K>(\n  items: TagCloudItemProps<K>[],\n  getItem: (itemInfo: ItemInfo, items: TagCloudItemProps<K>[]) => TagCloudItemProps<K> | undefined,\n  focusedItem: ItemInfo,\n  hoveredItem?: ItemInfo,\n  datatip?: string\n) {\n  if (datatip) return datatip;\n  const isPointerActive = hoveredItem?.isCurrent;\n\n  if (isPointerActive && hoveredItem.idx != null) {\n    return getItem(hoveredItem, items)?.accessibleLabel;\n  }\n  if (focusedItem && focusedItem.isCurrent) {\n    return getItem(focusedItem, items)?.accessibleLabel;\n  }\n  return;\n}\n\n/**\n * Returns the value of the data-oj-item-index attribute for a given element.\n * @param element The HTML element.\n */\nexport function getItemInfo(element: HTMLElement) {\n  const itemIdx = element.dataset['idx'];\n  if (itemIdx == null) return;\n\n  return {\n    idx: Number(itemIdx)\n  };\n}\n\n/**\n * Compares if two ItemInfo are equal\n * @param item1\n * @param item2\n * @returns\n */\nexport function isEqualItem(item1?: ItemInfo, item2?: ItemInfo) {\n  return item1?.idx === item2?.idx;\n}\n\n/**\n * Checks if the item is the currentItem and if the focus ring\n * is visible.\n * @param itemInfo ItemInfo\n * @param itemId Item index\n */\nexport function hasFocusRing(itemInfo: ItemInfo, itemIdx: number) {\n  if (!itemInfo.isFocusVisible) return false;\n  const { idx: idx } = itemInfo;\n\n  return idx === itemIdx;\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { JSX } from 'preact';\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { BundleType } from '../resources/nls/bundle';\nimport { getItemAriaProps } from './TagCloudUtils';\nimport { styles } from './themes/TagCloudStyles.css';\n\nexport type TagItemProps<K> = {\n  id: K;\n  label: string;\n  accessibleLabel?: string;\n  value: number;\n  fontSize: number;\n  itemIdx?: number;\n  supportsSelection?: boolean;\n  supportsAction?: boolean;\n  translations?: BundleType;\n  x?: number;\n  y?: number;\n  w?: number;\n  h?: number;\n  url?: string;\n  isHighlighted?: boolean;\n  isSelected?: boolean;\n  isCurrent?: boolean;\n  isFocused?: boolean;\n  isReadonly?: boolean;\n  class?: string;\n  style?: JSX.CSSProperties;\n  activeId?: string;\n};\n\nconst TagCloudItem = <K,>(props: TagItemProps<K>) => {\n  const {\n    itemBase,\n    itemStyle,\n    hoverUnselectedItemStyle,\n    selectedItemStyle,\n    hoveredSelectedItemStyle,\n    dimmedItemStyle,\n    interactiveCursorStyle\n  } = styles;\n  const isNotDimmed = props.isHighlighted || props.isHighlighted == null; // null means no highlighting feature\n\n  const itemClasses = classNames([\n    itemBase,\n    props.isSelected ? selectedItemStyle : itemStyle,\n    props.isCurrent\n      ? props.isSelected\n        ? hoveredSelectedItemStyle\n        : props.isFocused || props.supportsSelection\n        ? hoverUnselectedItemStyle\n        : ''\n      : '',\n    isNotDimmed ? '' : dimmedItemStyle,\n    props.supportsAction || props.supportsSelection ? interactiveCursorStyle : ''\n  ]);\n\n  const itemAriaProps = getItemAriaProps(\n    !!props.supportsSelection,\n    props.translations,\n    props.isSelected,\n    props.accessibleLabel\n  );\n  return (\n    <div\n      class={itemClasses}\n      data-id={`${props.id}`}\n      data-idx={props.itemIdx}\n      style={{\n        ...props.style,\n        transform: `translate(${props.x}px,${props.y}px)`,\n        fontSize: props.fontSize\n      }}\n      id={props.activeId}\n      {...itemAriaProps}>\n      {props.label}\n    </div>\n  );\n};\n\nexport { TagCloudItem };\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { ItemInputDetail, ItemInfo, TagCloudItemProps } from './TagCloud.type';\n\n/**\n * Returns the item based on item info in a tag cloud.\n * @param itemInfo\n * @param items\n * @returns\n */\nfunction getItem<K>(itemInfo: ItemInfo, items: TagCloudItemProps<K>[]) {\n  const { idx } = itemInfo;\n  return items[idx];\n}\n\n/**\n * Returns the next item's info in a tag cloud.\n * @param itemInfo\n * @param items\n * @returns\n */\nfunction getNextItemInfo<K>(itemInfo: ItemInfo, items: TagCloudItemProps<K>[]) {\n  let idx = itemInfo.idx;\n\n  idx = Math.min(items.length - 1, idx + 1);\n  return { idx, id: items[idx].id };\n}\n\n/**\n * Returns the previous item's info in a tag cloud.\n * @param itemInfo\n * @param items\n * @returns\n */\nfunction getPrevItemInfo<K>(itemInfo: ItemInfo, items: TagCloudItemProps<K>[]) {\n  let idx = itemInfo.idx;\n\n  idx = Math.max(0, idx - 1);\n  return { idx, id: items[idx].id };\n}\n\n/**\n * Returns utils functions for navigation in a tag cloud.\n * @param items\n * @returns\n */\nexport function getTagCloudNavUtils<K>(items: TagCloudItemProps<K>[]) {\n  return {\n    getItem: (itemInfo: ItemInfo) => {\n      return getItem(itemInfo, items);\n    },\n    getDetailFromInfo: (itemInfo?: ItemInfo): ItemInputDetail<K> => {\n      if (!itemInfo) {\n        return { id: undefined };\n      }\n      const item = getItem(itemInfo, items);\n      return { id: item.id };\n    },\n    getPrevItemInfo: (itemInfo: ItemInfo) => {\n      return getPrevItemInfo(itemInfo, items);\n    },\n    getNextItemInfo: (itemInfo: ItemInfo) => {\n      return getNextItemInfo(itemInfo, items);\n    }\n  };\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { Ref, useLayoutEffect, useState } from 'preact/hooks';\nimport { useTooltipControlled } from '../hooks/UNSAFE_useTooltip';\nimport { ItemInfo } from './TagCloud.type';\nimport { useUser } from '../hooks/UNSAFE_useUser';\nimport { TagItemProps } from './TagCloudItem';\n\ntype props<K> = {\n  text?: string;\n  rootRef: Ref<HTMLDivElement>;\n  focusedItemInfo: ItemInfo;\n  focusedItemRef: Ref<TagItemProps<K> | null>;\n};\n\nconst DEFAULT_OFFSET = 8;\n\n/**\n * Calculate the datatip offset for datatip when keyboard focus is active.\n * @param rootRef The ref for root of the tag cloud.\n * @param currentItem The ItemInfo of the current keyboard focused item.\n * @param isRtl The direction.\n * @param focusedItemRef The ref for currentItem node.\n * @returns\n */\nconst calculateOffset = <K>(\n  rootRef: Ref<HTMLDivElement>,\n  currentItem: ItemInfo,\n  isRtl: boolean,\n  focusedItemRef: Ref<TagItemProps<K> | null>\n) => {\n  let crossAxis = 0;\n  let mainAxisOffset = DEFAULT_OFFSET;\n  if (\n    focusedItemRef?.current &&\n    currentItem.isCurrent &&\n    rootRef.current &&\n    focusedItemRef?.current.x != null &&\n    focusedItemRef?.current.w != null &&\n    focusedItemRef?.current.y != null &&\n    focusedItemRef?.current.h != null\n  ) {\n    const rootDim = rootRef.current.getBoundingClientRect(); // TODO: make this more efficient\n    crossAxis =\n      (isRtl ? -1 : 1) * focusedItemRef.current.x +\n      focusedItemRef.current.w / 2 -\n      rootDim.width / 2;\n    mainAxisOffset += -1 * focusedItemRef.current.y;\n  }\n  return { crossAxis, mainAxis: mainAxisOffset };\n};\n\n/**\n * Returns the datatip.\n * @param text The text string for the tag cloud item.\n * @param rootRef The ref for root of the tag cloud.\n * @param focusedItemRef The ref for focused item node.\n * @param focusedItemInfo The ItemInfo for focused item node.\n * @returns\n */\nexport const useTagCloudDatatip = <K>({\n  text,\n  rootRef,\n  focusedItemRef,\n  focusedItemInfo\n}: props<K>) => {\n  const { direction } = useUser();\n  const isRtl = direction === 'rtl';\n  const [offset, setOffset] = useState<{ mainAxis?: number; crossAxis?: number }>(\n    calculateOffset(rootRef, focusedItemInfo, isRtl, focusedItemRef)\n  );\n\n  const [isOpen, setIsOpen] = useState<boolean>(false);\n\n  useLayoutEffect(() => {\n    setOffset(calculateOffset(rootRef, focusedItemInfo, isRtl, focusedItemRef));\n  }, [focusedItemInfo]);\n\n  const anchor = focusedItemInfo?.isCurrent ? 'element' : 'pointer';\n  const { tooltipContent, tooltipProps } = useTooltipControlled({\n    text: text,\n    position: 'top',\n    isDisabled: false,\n    variant: 'datatip',\n    anchor: { x: anchor, y: anchor },\n    offset: offset,\n    isOpen,\n    onToggle: ({ value }) => setIsOpen(value)\n  });\n  return { datatipContent: tooltipContent, datatipProps: tooltipProps };\n};\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { TagCloudItem, TagItemProps } from './TagCloudItem';\nimport { TagCloudProps } from './TagCloud.type';\nimport { getAriaProps, getDatatipText, getItemProps, getLayout } from './TagCloudUtils';\nimport { getTagCloudNavUtils } from './TagCloudNavUtils';\nimport { useEvents } from './useEvents';\nimport { TrackResizeContainer } from '../PRIVATE_TrackResizeContainer';\nimport { useTagCloudDatatip } from './useTagCloudDatatip';\nimport { mergeProps } from '../utils/UNSAFE_mergeProps';\nimport { useLayoutEffect, useRef, useState } from 'preact/hooks';\nimport { useTranslationBundle } from '../hooks/UNSAFE_useTranslationBundle';\nimport type { BundleType } from '../resources/nls/bundle';\nimport { useTextDimensions } from '../hooks/PRIVATE_useTextDimensions';\nimport { useUser } from '../hooks/UNSAFE_useUser';\nimport { baseStyles } from './themes/TagCloudStyles.css';\nimport { useSelection } from '../hooks/PRIVATE_useVizSelection';\nimport { getItemInfo } from './TagCloudUtils';\n\n/**\n * Tag clouds are used to display text data with the importance of each tag shown with font size or color.\n */\nexport function TagCloud<K extends string | number>({\n  items,\n  onItemAction,\n  onItemInput,\n  ...props\n}: TagCloudProps<K>) {\n  const rootRef = useRef<HTMLDivElement>(null);\n  const focusedItemRef = useRef<TagItemProps<K> | null>(null);\n  const translations = useTranslationBundle<BundleType>('@oracle/oraclejet-preact');\n\n  const filteredItems = items.filter((i) => !props.hiddenIds?.includes(i.id));\n\n  const hasData = filteredItems && filteredItems.length !== 0;\n  const supportsSelection = !!(props.selectionMode && props.selectionMode !== 'none');\n  const supportsAction = onItemAction != null;\n  const isReadOnly = supportsAction && onItemInput === null;\n\n  const ariaProps = getAriaProps(translations, hasData, props.accessibleLabel);\n\n  const { getItem, getDetailFromInfo, getPrevItemInfo, getNextItemInfo } =\n    getTagCloudNavUtils(filteredItems);\n\n  const { hoveredItemInfo, focusedItemInfo, ...eventsProps } = useEvents<K>(\n    !isReadOnly && hasData,\n    getDetailFromInfo,\n    getPrevItemInfo,\n    getNextItemInfo,\n    onItemAction,\n    onItemInput\n  );\n\n  const datatipText = getDatatipText(\n    filteredItems,\n    getItem,\n    focusedItemInfo,\n    hoveredItemInfo,\n    props.datatip\n  );\n  const { datatipContent, datatipProps } = useTagCloudDatatip({\n    text: datatipText,\n    rootRef,\n    focusedItemInfo,\n    focusedItemRef\n  });\n\n  const idExtracter = (event: Event) => {\n    // return focused item for keyboard event.\n    // eventsProps should have already updated the focused item\n    const info =\n      event.type === 'keyup' ? focusedItemInfo : getItemInfo(event.target as HTMLElement);\n    return getDetailFromInfo(info).id;\n  };\n\n  const selectionProps = useSelection<K>({\n    idExtracter,\n    selection: props.selectedIds,\n    selectionMode: props.selectionMode,\n    onChange: props.onSelectionChange\n  });\n\n  const mergedProps = mergeProps(eventsProps, datatipProps, selectionProps);\n  const { direction } = useUser();\n\n  return (\n    <TrackResizeContainer width={props.width} height={props.height}>\n      {(width, height) => {\n        const { textMeasureContent, getTextDimensions } = useTextDimensions();\n        const [layoutTags, setLayoutTags] = useState<TagItemProps<K>[]>([]);\n\n        useLayoutEffect(() => {\n          if (!getTextDimensions || !hasData) return;\n          setLayoutTags(\n            getLayout(\n              props.layout,\n              filteredItems,\n              width,\n              height,\n              direction === 'rtl',\n              getTextDimensions\n            )\n          );\n        }, [props.layout, filteredItems, width, height, direction, getTextDimensions]);\n\n        return (\n          <div\n            ref={rootRef}\n            tabIndex={isReadOnly ? undefined : 0}\n            style={{ width, height }}\n            class={baseStyles}\n            {...ariaProps}\n            {...mergedProps}>\n            {layoutTags.map((item, itemIndex) => {\n              const itemProps = getItemProps(\n                item,\n                itemIndex,\n                supportsSelection,\n                isReadOnly,\n                hoveredItemInfo,\n                props.selectedIds,\n                focusedItemInfo,\n                props.highlightedIds,\n                eventsProps['aria-activedescendant']\n              );\n              const isFocusedItem = focusedItemInfo.idx === itemIndex;\n              isFocusedItem ? (focusedItemRef.current = item) : null;\n              return (\n                <TagCloudItem\n                  fontSize={item.fontSize}\n                  x={item.x}\n                  y={item.y}\n                  accessibleLabel={item.accessibleLabel}\n                  supportsSelection={supportsSelection}\n                  supportsAction={supportsAction}\n                  translations={translations}\n                  {...itemProps}\n                />\n              );\n            })}\n            {textMeasureContent}\n            {datatipContent}\n          </div>\n        );\n      }}\n    </TrackResizeContainer>\n  );\n}\n","import { useRef, useState } from 'preact/hooks';\nimport { useUser } from '../hooks/UNSAFE_useUser';\nimport { ItemActionDetail, ItemInputDetail, ItemInfo } from './TagCloud.type';\nimport { getItemInfo, isEqualItem } from './TagCloudUtils';\nimport { getRandomId } from '../utils/PRIVATE_visLayoutUtils/LayoutUtils';\n\nexport function useEvents<K>(\n  isInteractive: boolean,\n  getDetailFromInfo: (info?: ItemInfo) => ItemInputDetail<K>,\n  getPrevItemInfo: (info: ItemInfo) => ItemInfo,\n  getNextItemInfo: (info: ItemInfo) => ItemInfo,\n  onItemAction?: (detail: ItemActionDetail<K>) => void,\n  onInput?: (detail: ItemInputDetail<K>) => void\n) {\n  const [focusedItemInfo, setfocusedItemInfo] = useState<ItemInfo>({ idx: 0 });\n  const [hoveredItemInfo, sethoveredItemInfo] = useState<ItemInfo>();\n\n  const activeId = useRef<string>();\n\n  const { direction } = useUser();\n  const isRtl = direction === 'rtl';\n\n  const cancelEvent = (event: Event) => {\n    event.preventDefault();\n    event.stopPropagation();\n  };\n\n  const hoverHandler = (event: PointerEvent) => {\n    const itemInfo = getItemInfo(event.target as HTMLElement);\n    if (!isEqualItem(itemInfo, hoveredItemInfo)) {\n      sethoveredItemInfo(itemInfo && { ...itemInfo, isCurrent: true });\n      activeId.current = getRandomId();\n      if (isInteractive) {\n        setfocusedItemInfo({ ...focusedItemInfo, isCurrent: false });\n        onInput?.(getDetailFromInfo(itemInfo));\n      }\n    }\n  };\n\n  const pointerLeaveHandler = () => {\n    sethoveredItemInfo(undefined);\n    activeId.current = undefined;\n    if (isInteractive) {\n      onInput?.(getDetailFromInfo());\n    }\n  };\n\n  if (!isInteractive) {\n    return {\n      focusedItemInfo,\n      hoveredItemInfo,\n      // include pointer leave and pointer move for datatip\n      onPointerLeave: pointerLeaveHandler,\n      onPointerMove: hoverHandler\n    };\n  }\n\n  function updatefocusedItemInfo(itemInfo: ItemInfo) {\n    onInput?.(getDetailFromInfo(itemInfo));\n    activeId.current = getRandomId();\n    setfocusedItemInfo(itemInfo);\n  }\n\n  function handleKeyboardInput(item: ItemInfo) {\n    if (!isEqualItem(item, focusedItemInfo)) {\n      item.isCurrent = true;\n      item.isFocusVisible = true;\n      if (hoveredItemInfo) {\n        sethoveredItemInfo({ ...hoveredItemInfo, isCurrent: false });\n      }\n      updatefocusedItemInfo(item);\n    }\n  }\n\n  const triggerOnAction = () => {\n    const { id } = getDetailFromInfo(focusedItemInfo);\n    if (id != null) {\n      onItemAction?.({ id });\n      activeId.current = getRandomId();\n    }\n  };\n\n  const pointerUpHandler = (event: PointerEvent) => {\n    const itemInfo = getItemInfo(event.target as HTMLElement);\n    if (itemInfo != null) {\n      setfocusedItemInfo(itemInfo);\n      const { id } = getDetailFromInfo(itemInfo);\n      if (id != null) {\n        onItemAction?.({ id });\n        activeId.current = getRandomId();\n      }\n    } else onItemAction?.({ id: undefined });\n  };\n\n  const keyDownHandler = (event: KeyboardEvent) => {\n    const key = event.key;\n    switch (key) {\n      case 'Tab':\n        return;\n      case 'ArrowDown': {\n        const nextItemInfo = getNextItemInfo(focusedItemInfo);\n        handleKeyboardInput(nextItemInfo);\n        break;\n      }\n      case 'ArrowUp': {\n        const nextItemInfo = getPrevItemInfo(focusedItemInfo);\n        handleKeyboardInput(nextItemInfo);\n        break;\n      }\n      case 'ArrowRight': {\n        const nextItemInfo = isRtl\n          ? getPrevItemInfo(focusedItemInfo)\n          : getNextItemInfo(focusedItemInfo);\n        handleKeyboardInput(nextItemInfo);\n        break;\n      }\n      case 'ArrowLeft': {\n        const nextItemInfo = isRtl\n          ? getNextItemInfo(focusedItemInfo)\n          : getPrevItemInfo(focusedItemInfo);\n        handleKeyboardInput(nextItemInfo);\n        break;\n      }\n    }\n    cancelEvent(event);\n  };\n\n  const keyUpHandler = (event: KeyboardEvent) => {\n    const key = event.code;\n    switch (key) {\n      case 'Space': {\n        triggerOnAction();\n        break;\n      }\n      case 'Enter': {\n        triggerOnAction();\n        break;\n      }\n      case 'Tab': {\n        updatefocusedItemInfo({\n          ...focusedItemInfo,\n          isCurrent: true,\n          isFocusVisible: true\n        });\n        break;\n      }\n    }\n  };\n\n  const blurHandler = () => {\n    if (hoveredItemInfo != null || focusedItemInfo.isCurrent) {\n      onInput?.(getDetailFromInfo(undefined));\n    }\n    const itemInfo = { ...focusedItemInfo, isCurrent: false, isFocusVisible: false };\n    setfocusedItemInfo(itemInfo);\n  };\n\n  return {\n    focusedItemInfo,\n    hoveredItemInfo,\n    'aria-activedescendant': activeId.current,\n    onPointerUp: pointerUpHandler,\n    onPointerMove: hoverHandler,\n    onKeyUp: keyUpHandler,\n    onKeyDown: keyDownHandler,\n    onPointerLeave: pointerLeaveHandler,\n    onBlur: blurHandler\n  };\n}\n"],"names":["HOVER_OPACITY","HOVER_SELECTED_OPACITY","BOTTOM_PADDING","fontSizeCalc","value","minValue","maxValue","range","Math","ceil","getInitialFontSize","items","fontSizeArr","Number","MAX_VALUE","i","length","min","max","x","push","fontSize","calculateLineBreaks","arDims","width","lines","curWidth","w","getLayout","layout","tagcloudW","tagcloudH","isRTL","getTextDimensions","layoutTagCloud","tagWordData","maxWidth","maxHeight","maxFontSize","initialFontItems","tag","tagDimensions","label","height","h","scale","arLines","minScale","maxScale","k","lineStart","lineEnd","hPadding","maxLineHeight","justified","lineWidth","j","flowPadding","bottomY","curX","m","tagLine","tagItemFontSize","y","getRectangleLayout","positions","steps","xrStep","yrStep","thetaStep","PI","bounds","cosCache","sinCache","placed","step","stepIncrement","lastCollisionIndex","lookup","undefined","cos","sin","_x","_y","tagCloudDiv","intersects","getUnion","cx","cy","tagItemX","tagItem","tagItemY","tagItemW","tagItemH","getCloudLayout","getItemProps","item","itemIdx","supportsSelection","isReadOnly","hoveredItem","selectedIds","focusedItem","highlightedIds","activeId","style","isCurrent","isFocusedItem","idx","isHoveredItem","isHighlighted","id","Set","has","isItemHighlighted","isSelected","isItemSelected","color","backgroundColor","backgroundImage","getContrastingTextColor","_lightenColor","isFocused","hasFocusRing","key","getItemInfo","element","dataset","isEqualItem","item1","item2","itemInfo","isFocusVisible","TagCloudItem","props","itemBase","itemStyle","hoverUnselectedItemStyle","selectedItemStyle","hoveredSelectedItemStyle","dimmedItemStyle","interactiveCursorStyle","styles","isNotDimmed","itemClasses","classNames","supportsAction","itemAriaProps","translations","accessibleLabel","dataVisualization_stateSelected","dataVisualization_stateUnselected","role","_jsx","jsx","class","transform","children","getItem","getTagCloudNavUtils","getDetailFromInfo","getPrevItemInfo","getNextItemInfo","calculateOffset","rootRef","currentItem","isRtl","focusedItemRef","crossAxis","mainAxisOffset","current","rootDim","getBoundingClientRect","mainAxis","useTagCloudDatatip","text","focusedItemInfo","direction","useUser","offset","setOffset","useState","isOpen","setIsOpen","useLayoutEffect","anchor","tooltipContent","tooltipProps","useTooltipControlled","position","isDisabled","variant","onToggle","datatipContent","datatipProps","onItemAction","onItemInput","useRef","useTranslationBundle","filteredItems","filter","hiddenIds","includes","hasData","selectionMode","ariaProps","dataVisualization_noData","getAriaProps","hoveredItemInfo","eventsProps","isInteractive","onInput","setfocusedItemInfo","sethoveredItemInfo","hoverHandler","event","target","getRandomId","pointerLeaveHandler","onPointerLeave","onPointerMove","updatefocusedItemInfo","handleKeyboardInput","triggerOnAction","onPointerUp","onKeyUp","code","onKeyDown","preventDefault","stopPropagation","cancelEvent","onBlur","useEvents","datatipText","datatip","isPointerActive","getDatatipText","selectionProps","useSelection","idExtracter","info","type","selection","onChange","onSelectionChange","mergedProps","mergeProps","TrackResizeContainer","textMeasureContent","useTextDimensions","layoutTags","setLayoutTags","_jsxs","ref","tabIndex","baseStyles","map","itemIndex","itemProps"],"mappings":"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"}