{"version":3,"file":"UNSAFE_IntlDateTime.js","sources":["../../src/UNSAFE_IntlDateTime/CalendarUtils.ts","../../src/UNSAFE_IntlDateTime/ISODateTimezoneOffset.ts","../../src/UNSAFE_IntlDateTime/NativeDateTimeConstants.ts","../../src/UNSAFE_IntlDateTime/dateTimeUtils.ts","../../src/UNSAFE_IntlDateTime/NativeParserImpl.ts","../../src/UNSAFE_IntlDateTime/formatParse.ts","../../../../node_modules/ramda/src/internal/_curryN.js","../../../../node_modules/ramda/src/curryN.js","../../src/UNSAFE_IntlDateTime/getFormatParse.ts"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\n// This class fills in the localeElements by using the data from Intl.DateTimeFormat.\n// This data is used for parsing.\n\ntype WidthOptions = 'short' | 'narrow' | 'long';\ntype CalendarWidthNames = 'abbreviated' | 'narrow' | 'wide';\n\ntype WeekdayNames = 'sun' | 'mon' | 'tue' | 'wed' | 'thu' | 'fri' | 'sat';\n\ntype MonthType = {\n  '1': string;\n  '2': string;\n  '3': string;\n  '4': string;\n  '5': string;\n  '6': string;\n  '7': string;\n  '8': string;\n  '9': string;\n  '10': string;\n  '11': string;\n  '12': string;\n};\n\ntype DayType = {\n  sun: string;\n  mon: string;\n  tue: string;\n  wed: string;\n  thu: string;\n  fri: string;\n  sat: string;\n};\ntype DayPeriodType = {\n  am: string;\n  pm: string;\n};\ntype ErasWidthType = {\n  '0': string;\n  '1': string;\n};\ntype MonthWidthType = {\n  abbreviated: MonthType;\n  narrow: MonthType;\n  wide: MonthType;\n};\ntype DayWidthType = {\n  abbreviated: DayType;\n  narrow: DayType;\n  wide: DayType;\n};\ntype MonthsNodeType = {\n  format: MonthWidthType;\n  'stand-alone': MonthWidthType;\n};\ntype DaysNodeType = {\n  format: DayWidthType;\n  'stand-alone': DayWidthType;\n};\n\ntype DayPeriodFormatWidthType = {\n  wide: DayPeriodType;\n};\ntype DayPeriodsNodeType = {\n  format: DayPeriodFormatWidthType;\n};\ntype ErasType = {\n  eraNarrow: ErasWidthType;\n  eraAbbr: ErasWidthType;\n  eraName: ErasWidthType;\n};\nexport type CalendarNodeType = {\n  months: MonthsNodeType;\n  days: DaysNodeType;\n  dayPeriods: DayPeriodsNodeType;\n  eras: ErasType;\n  locale: string;\n};\n\ntype EraDesc = Array<{ era: string; start: string }>;\n\nexport class CalendarUtils {\n  // calendars[locale][calendarname]\n  public static calendars: Record<string, Record<string, CalendarNodeType>> | undefined;\n\n  private static readonly _monthNamesFormatMap = {\n    short: 'abbreviated',\n    narrow: 'narrow',\n    long: 'wide'\n  } as const;\n  private static readonly _weekdaysFormatMap = {\n    1: 'sun',\n    2: 'mon',\n    3: 'tue',\n    4: 'wed',\n    5: 'thu',\n    6: 'fri',\n    7: 'sat'\n  } as const;\n\n  // The following locales have month name like '1<literal>' (where literal is the lang's character for 'month')\n  // if we pass in the options\n  // month:'long' or month:'short' the corresponding pattern in CLDR is 'M<literal>'\n  // which is month numeric followed by the <literal>. As a result formatToParts\n  // will return {type: month, value:1} followed by {type: literal, value:<literal>}.\n  // These locales have same names for stand-alone and format month names.\n  // As a work around we will get the format month names for these\n  // locales using the stand-alone option instead of formatToParts.\n  // For example: in ja-JP locale we have:\n  // \"months\": {\n  //   \"format\": {\n  //       \"abbreviated\": {\n  //           \"1\": \"1\\u6708\",\n  //  }\n  // but the corresponding pattern is \"yMMMd\": \"y\\u5e74M\\u6708d\\u65e5\"\n  // so formatToParts will return\n  // {type: month, value:1} followed by {type: literal, value:'\\u6708d'}\n  // As a result we get '1' as month name in the calendar data instead of '1\\u6708'\n\n  private static exceptionLocales = [\n    'ja',\n    'ja-JP',\n    'zh',\n    'zh-Hans',\n    'zh-Hans-CN',\n    'zh-Hans-HK',\n    'zh-Hans-MO',\n    'zh-Hans-SG',\n    'zh-Hant',\n    'zh-Hant-HK',\n    'zh-Hant-MO',\n    'zh-Hant-TW'\n  ];\n  // Uses the Intl.DateTimeFormat formatToParts to get the day periods.\n  // Returns this object\n  // \"dayPeriods\": {\n  //  \"format\": {\n  //    \"wide\": {\n  //      \"am\": \"AM\",\n  //      \"pm\": \"PM\"\n  //    }}}\n  private static _getDayPeriods(locale: string, calendar: string) {\n    const date = new Date(2019, 0, 1, 0, 0, 0);\n\n    function getDayPeriodsFromFormatToParts(formatter: Intl.DateTimeFormat) {\n      const formatParts = formatter.formatToParts(date);\n      const eraPart = formatParts.find((value) => value.type === 'dayPeriod');\n      // TODO Era is failing for chinese calendar. Need to fix it\n      if (eraPart) {\n        return eraPart.value;\n      }\n      return '';\n    }\n    const options: {\n      hour: Intl.DateTimeFormatOptions['hour'];\n      hour12: Intl.DateTimeFormatOptions['hour12'];\n    } = { hour: 'numeric', hour12: true };\n    const formatterLocale = CalendarUtils.getFormatterLocale(locale, calendar);\n    const formatter = new Intl.DateTimeFormat(formatterLocale, options);\n    const amValue = getDayPeriodsFromFormatToParts(formatter);\n    date.setHours(20);\n    const pmValue = getDayPeriodsFromFormatToParts(formatter);\n    return { format: { wide: { am: amValue, pm: pmValue } } };\n  }\n\n  private static getFormatterLocale(locale: string, calendar: string) {\n    return locale + '-u-ca-' + calendar;\n  }\n\n  // Example of an eras from localeElements is this, but this fn gets all the data, not just eraAbbr.\n  // \"eras\": {\n  //   \"eraAbbr\": {\n  //     \"0\": \"BC\",\n  //     \"1\": \"AD\"\n  //   }\n  // },\n  private static _getEras(locale: string, calendar: string) {\n    const eras: EraDesc = [{ era: '0', start: '2000-02-11T00:00:00' }];\n    const cal: ErasType = {\n      eraNarrow: { '0': '', '1': '' },\n      eraAbbr: { '0': '', '1': '' },\n      eraName: { '0': '', '1': '' }\n    };\n\n    function getEraFromFormatToParts(formatter: Intl.DateTimeFormat, date: Date) {\n      const formatParts = formatter.formatToParts(date);\n      const eraPart = formatParts.find((value) => value.type === 'era');\n      if (eraPart) {\n        return eraPart.value;\n      }\n      return '';\n    }\n\n    const eraLenArray: Array<NonNullable<Intl.DateTimeFormatOptions['era']>> = [\n      'narrow',\n      'short',\n      'long'\n    ];\n    const formatterLocale = CalendarUtils.getFormatterLocale(locale, calendar);\n    // get the erra name for narrow, short, long.\n    // e.g., A, AD, Anno Domini\n    // this is used to map the era option value from Intl.DateTimeFormat to\n    // what we want to short in our CalendarNode\n    const eraMap = {\n      narrow: 'eraNarrow',\n      short: 'eraAbbr',\n      long: 'eraName'\n    };\n\n    for (let i = 0; i < eras.length; i++) {\n      const date = new Date(eras[i].start);\n      for (let j = 0; j < eraLenArray.length; j++) {\n        const eraLenName = eraLenArray[j];\n        const options: {\n          year: Intl.DateTimeFormatOptions['year'];\n          month: Intl.DateTimeFormatOptions['month'];\n          day: Intl.DateTimeFormatOptions['day'];\n          era: Intl.DateTimeFormatOptions['era'];\n        } = { year: 'numeric', month: 'numeric', day: 'numeric', era: eraLenName };\n        const formatter = new Intl.DateTimeFormat(formatterLocale, options);\n        const eraForLength = getEraFromFormatToParts(formatter, date);\n        const eraNameForNode = eraMap[eraLenName] as keyof ErasType;\n        const eraObj = { '0': eraForLength, '1': eraForLength };\n        cal[eraNameForNode] = eraObj;\n      }\n    }\n    return cal;\n  }\n\n  private static _fillMonthAndDays(\n    locale: string,\n    calendar: string,\n    widthVal: CalendarWidthNames,\n    options: Intl.DateTimeFormatOptions,\n    isStandAlone: boolean\n  ) {\n    // These date are used to fill in the months and weekdays.\n    // Each date is a different day of week. Like, the first is sun, the second is mon, etc.\n    const dates: Array<Array<number>> = [\n      [2020, 0, 5],\n      [2020, 1, 3],\n      [2020, 2, 3],\n      [2020, 3, 1],\n      [2020, 4, 7],\n      [2020, 5, 5],\n      [2020, 6, 4],\n      [2020, 7, 1],\n      [2020, 8, 1],\n      [2020, 9, 1],\n      [2020, 10, 1],\n      [2020, 11, 1]\n    ];\n\n    function getMonthFromFormatToParts(formatParts: Intl.DateTimeFormatPart[]) {\n      const monthPart = formatParts.find((value) => value.type === 'month');\n      if (monthPart) {\n        return monthPart.value;\n      }\n      return null;\n    }\n\n    function getWeekdayFromFormatToParts(formatParts: Intl.DateTimeFormatPart[]) {\n      const weekdayPart = formatParts.find((value) => value.type === 'weekday');\n      if (weekdayPart) {\n        return weekdayPart.value;\n      }\n      return null;\n    }\n\n    const formatterLocale = CalendarUtils.getFormatterLocale(locale, calendar);\n    const formatter = new Intl.DateTimeFormat(formatterLocale, options);\n\n    type MonthFormatType = {\n      abbreviated?: Partial<MonthType>;\n      narrow?: Partial<MonthType>;\n      wide?: Partial<MonthType>;\n    };\n    type DayFormatType = {\n      abbreviated?: Partial<DayType>;\n      narrow?: Partial<DayType>;\n      wide?: Partial<DayType>;\n    };\n    const calMonthFormat: MonthFormatType = {};\n    const calDayFormat: DayFormatType = {};\n\n    // It loops from 0 to 12, dates is for each month. [0] is the year, [1] is the month, [2] is the day\n    // create a new date with year, month, day. each date[j] is a different month of the year, and it also has a different weekday.\n    for (let j = 0; j < dates.length; j++) {\n      const index = j + 1; // 1 to 12\n      const dayIndexVal: WeekdayNames =\n        CalendarUtils._weekdaysFormatMap[index as keyof typeof CalendarUtils._weekdaysFormatMap];\n      const date = new Date(dates[j][0], dates[j][1], dates[j][2]);\n      const formatParts = formatter.formatToParts(date);\n      let month;\n      let weekday;\n      // for stand-alone (e.g., {month: 'short'}), there is only one entry, so we can just get the\n      // value of format. No need for formatToParts to pull out just the month piece.\n      // Note that for ja format gives you the month kanji character too and formatToParts month is only the number. The kanji character is in the literal.\n      if (isStandAlone) {\n        month = formatter.format(date);\n        weekday = formatter.format(date);\n      } else {\n        month = getMonthFromFormatToParts(formatParts);\n        weekday = getWeekdayFromFormatToParts(formatParts);\n      }\n      // store the month and weekday in the obj; only fill in weekday if (index <= 7)\n      if (calMonthFormat[widthVal] === undefined) {\n        calMonthFormat[widthVal] = {};\n      }\n      // @ts-ignore\n      calMonthFormat[widthVal][index] = month;\n      if (index <= 7) {\n        if (calDayFormat[widthVal] === undefined) {\n          calDayFormat[widthVal] = {};\n        }\n        // @ts-ignore\n        calDayFormat[widthVal][dayIndexVal] = weekday;\n      }\n    }\n    return {\n      monthFormat: calMonthFormat, // This will be an object like {'abbreviated': Partial<MonthType}\n      dayFormat: calDayFormat\n    };\n  }\n\n  private static _getFormatMonthAndDays(locale: string, calendar: string) {\n    const calMonths = [];\n    const calDays = [];\n    // Intl.DateTimeFormat's month can take: \"numeric\" (e.g., 3)\"2-digit\" (e.g., 03)\"long\" (e.g., March)\"short\" (e.g., Mar) \"narrow\" (e.g., M).\n    const types: Array<WidthOptions> = ['short', 'narrow', 'long'];\n    for (let i = 0; i < types.length; i++) {\n      const options: Intl.DateTimeFormatOptions = {\n        month: types[i],\n        weekday: types[i],\n        year: 'numeric',\n        day: 'numeric'\n      };\n      // types get mapped to short: 'abbreviated', narrow: 'narrow', long: 'wide'\n      const widthVal = CalendarUtils._monthNamesFormatMap[types[i]]; // get alternate names for 'narrow', 'short', 'long'\n      const monthDayObjForWidth = CalendarUtils._fillMonthAndDays(\n        locale,\n        calendar,\n        widthVal,\n        options,\n        false\n      );\n\n      calMonths[i] = monthDayObjForWidth.monthFormat;\n      calDays[i] = monthDayObjForWidth.dayFormat;\n    }\n\n    const myMonthObj = Object.assign({}, ...calMonths);\n    const myDayObj = Object.assign({}, ...calDays);\n\n    const myMonthFormatObj: Partial<MonthsNodeType> = {};\n    myMonthFormatObj.format = myMonthObj;\n    const myDayFormatObj: Partial<DaysNodeType> = {};\n    myDayFormatObj.format = myDayObj;\n\n    myMonthFormatObj['stand-alone'] = myMonthFormatObj.format;\n    myDayFormatObj['stand-alone'] = myDayFormatObj.format;\n\n    return {\n      monthsNode: myMonthFormatObj as MonthsNodeType,\n      daysNode: myDayFormatObj as DaysNodeType\n    };\n  }\n\n  private static _getStandAloneDays(locale: string, calendar: string) {\n    const calDays = [];\n    // Intl.DateTimeFormat's weekday can take: \"long\" (e.g., Monday)\"short\" (e.g., Mon) \"narrow\" (e.g., M).\n    // stand-alone weekday is displayed when the options conatin only one attribute weekday: options = {weekday:'long'}\n    const types: Array<WidthOptions> = ['short', 'narrow', 'long'];\n    for (let i = 0; i < types.length; i++) {\n      const options: Intl.DateTimeFormatOptions = {\n        weekday: types[i]\n      };\n      // types get mapped to short: 'abbreviated', narrow: 'narrow', long: 'wide'\n      const widthVal = CalendarUtils._monthNamesFormatMap[types[i]]; // get alternate names for 'narrow', 'short', 'long'\n      const dayObjForWidth = CalendarUtils._fillMonthAndDays(\n        locale,\n        calendar,\n        widthVal,\n        options,\n        true\n      );\n      calDays[i] = dayObjForWidth.dayFormat;\n    }\n    const myDayObj = Object.assign({}, ...calDays);\n    const myDayStandAloneObj = { 'stand-alone': {} };\n    myDayStandAloneObj['stand-alone'] = myDayObj;\n    return {\n      daysNode: myDayStandAloneObj as DaysNodeType\n    };\n  }\n\n  private static _getStandAloneMonths(locale: string, calendar: string) {\n    const calMonths = [];\n    // Intl.DateTimeFormat's month can take: \"numeric\" (e.g., 3)\"2-digit\" (e.g., 03)\"long\" (e.g., March)\"short\" (e.g., Mar) \"narrow\" (e.g., M).\n    // stand-alone month is displayed when the options conatin only one attribute month: options = {month:'long'}\n    const types: Array<WidthOptions> = ['short', 'narrow', 'long'];\n    for (let i = 0; i < types.length; i++) {\n      const options = {\n        month: types[i]\n      };\n      // types get mapped to short: 'abbreviated', narrow: 'narrow', long: 'wide'\n      const widthVal = CalendarUtils._monthNamesFormatMap[types[i]]; // get alternate names for 'narrow', 'short', 'long'\n      const monthObjForWidth = CalendarUtils._fillMonthAndDays(\n        locale,\n        calendar,\n        widthVal,\n        options,\n        true\n      );\n      calMonths[i] = monthObjForWidth.monthFormat;\n    }\n    const myMonthObj = Object.assign({}, ...calMonths);\n    const myMonthStandAloneObj = { 'stand-alone': {} };\n    myMonthStandAloneObj['stand-alone'] = myMonthObj;\n    return {\n      monthsNode: myMonthStandAloneObj as MonthsNodeType\n    };\n  }\n  /**\n   * Fills in CalendarUtils.calendars[locale][calendar] public static object.\n   * @param locale locale name\n   * @param calendar calendar name\n   */\n  public static getCalendar(locale: string, calendar: string): CalendarNodeType {\n    CalendarUtils.calendars = CalendarUtils.calendars ?? {};\n    CalendarUtils.calendars[locale] = CalendarUtils.calendars[locale] ?? {};\n\n    if (CalendarUtils.calendars[locale][calendar] === undefined) {\n      const dayPeriodsObj = CalendarUtils._getDayPeriods(locale, calendar);\n      const erasObj = CalendarUtils._getEras(locale, calendar);\n      let monthFormat;\n      let dayFormat;\n      const standAloneMonths = CalendarUtils._getStandAloneMonths(locale, calendar);\n      const standAloneDays = CalendarUtils._getStandAloneDays(locale, calendar);\n      const useStandAlone = CalendarUtils.exceptionLocales.includes(locale);\n      // TODO this might only be needed for gregorian calendar. Need to check when\n      // we support other calendars\n      if (useStandAlone) {\n        monthFormat = standAloneMonths.monthsNode['stand-alone'];\n        dayFormat = standAloneDays.daysNode['stand-alone'];\n      } else {\n        const monthsDaysNodeObj = CalendarUtils._getFormatMonthAndDays(locale, calendar);\n        monthFormat = monthsDaysNodeObj.monthsNode.format;\n        dayFormat = monthsDaysNodeObj.daysNode.format;\n      }\n      const monthsNodes: MonthsNodeType = {\n        format: monthFormat,\n        'stand-alone': standAloneMonths.monthsNode['stand-alone']\n      };\n      const daysNodes: DaysNodeType = {\n        format: dayFormat,\n        'stand-alone': standAloneDays.daysNode['stand-alone']\n      };\n      CalendarUtils.calendars[locale][calendar] = {\n        dayPeriods: dayPeriodsObj,\n        months: monthsNodes,\n        days: daysNodes,\n        eras: erasObj,\n        locale: locale\n      };\n    }\n    return CalendarUtils.calendars[locale][calendar];\n  }\n}\n","/**\n * @license\n * Copyright (c) 2004 %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nexport type DateDef = {\n  year: number;\n  month: number; // 1-based!\n  date: number;\n  hours: number;\n  minutes: number;\n};\n// cache the converters\nconst formatterCache: Map<string, Intl.DateTimeFormat> = new Map();\n\nexport function getISODateOffset(date: DateDef, timeZone: string): number {\n  // Get the timezone-adjusted representation of the date parameter interpreted as UTC\n  const d = new Date(Date.UTC(date.year, date.month - 1, date.date, date.hours, date.minutes));\n  const utcDateAtTimezone = _applyTimezoneToDate(d, timeZone);\n  // get the offset of the target timezone (subject to a possible DTS change ajustment)\n  const offset = _getOffset(date, utcDateAtTimezone);\n  let adjustment = 0;\n  d.setTime(d.getTime() - offset * 60000);\n\n  // check whether the offset is correct\n  if (!_compareDates(_applyTimezoneToDate(d, timeZone), date)) {\n    // try to accommodate 'fall back'/move 1 hour west\n    adjustment = -60;\n    d.setTime(d.getTime() + 60 * 60000);\n    if (!_compareDates(_applyTimezoneToDate(d, timeZone), date)) {\n      // spring forward/move 1 hour east\n      // This case should always produce a match unless we are hitting the missing hour during the 'spring forward'\n      // JS Date() favors the DST in this case, so we will remain at the 'spring forward' offset even if _compareDates()\n      // would have returned false\n      adjustment = 60;\n      d.setTime(d.getTime() - 120 * 60000);\n    }\n  }\n  const result = offset + adjustment;\n  return result;\n}\n\nfunction _applyTimezoneToDate(d: Date, timeZone: string): DateDef {\n  const cnv = _getConverter(timeZone);\n  const formattedUTC = cnv.format(d);\n  const [localDate, localTime] = formattedUTC.split(',');\n  const [month, date, year] = localDate.split('/');\n  const [hours, minutes] = localTime.trim().split(':');\n  return {\n    year: parseInt(year),\n    month: parseInt(month),\n    date: parseInt(date),\n    hours: parseInt(hours),\n    minutes: parseInt(minutes)\n  };\n}\n\nfunction _getOffset(original: DateDef, asUTC: DateDef): number {\n  let originalMins = original.hours * 60 + original.minutes;\n  let utcMinutes = asUTC.hours * 60 + asUTC.minutes;\n  // any shift in year, month or day indicates the following day\n  let delta = original.year - asUTC.year;\n  if (delta == 0) {\n    delta = original.month - asUTC.month;\n    if (delta === 0) {\n      delta = original.date - asUTC.date;\n    }\n  }\n  if (delta > 0) {\n    originalMins += 24 * 60;\n  } else if (delta < 0) {\n    utcMinutes += 24 * 60;\n  }\n  return utcMinutes - originalMins;\n}\n\nfunction _compareDates(date1: DateDef, date2: DateDef) {\n  return (\n    date1.year === date2.year &&\n    date1.month === date2.month &&\n    date1.hours === date2.hours &&\n    date1.minutes === date2.minutes\n  );\n}\n\nfunction _getConverter(timezone: string) {\n  let formatter = formatterCache.get(timezone);\n  if (!formatter) {\n    formatter = new Intl.DateTimeFormat('en-US', {\n      year: 'numeric',\n      month: 'numeric',\n      day: 'numeric',\n      hour: 'numeric',\n      minute: 'numeric',\n      second: 'numeric',\n      hourCycle: 'h23',\n      timeZone: timezone\n    });\n    formatterCache.set(timezone, formatter);\n  }\n  return formatter;\n}\n","/**\n * @license\n * Copyright (c) 2004 %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nexport class NativeDateTimeConstants {\n  public static readonly _YEAR_AND_DATE_REGEXP = /(\\d{1,4})\\D+?(\\d{1,4})/g;\n  public static readonly _YMD_REGEXP = /(\\d{1,4})\\D+?(\\d{1,4})\\D+?(\\d{1,4})/g;\n  public static readonly _TIME_REGEXP =\n    /(\\d{1,2})(?:\\D(\\d{1,2}))?(?:\\D(\\d{1,2}))?(?:\\D(\\d{1,3}))?/g;\n  public static readonly _TIME_FORMAT_REGEXP = /h|H|K|k/g;\n\n  public static readonly _YEAR_REGEXP = /y{1,4}/;\n  public static readonly _MONTH_REGEXP = /M{1,5}/;\n  public static readonly _DAY_REGEXP = /d{1,2}/;\n  public static readonly _WEEK_DAY_REGEXP = /E{1,5}/;\n  public static readonly _HOUR_REGEXP = /h{1,2}|k{1,2}/i;\n  public static readonly _MINUTE_REGEXP = /m{1,2}/;\n  public static readonly _SECOND_REGEXP = /s{1,2}/;\n  public static readonly _FRACTIONAL_SECOND_REGEXP = /S{1,3}/;\n  public static readonly _AMPM_REGEXP = /a{1,2}/;\n  public static readonly _WORD_REGEXP = '(\\\\D+?\\\\s*)';\n\n  // This eslint disable require to make eacs happy\n  // eslint-disable-next-line no-useless-escape\n  public static readonly _ESCAPE_REGEXP = /([\\^$.*+?|\\[\\](){}])/g;\n\n  public static readonly _TOKEN_REGEXP =\n    /ccccc|cccc|ccc|cc|c|EEEEE|EEEE|EEE|EE|E|dd|d|MMMMM|MMMM|MMM|MM|M|LLLLL|LLLL|LLL|LL|L|yyyy|yy|y|hh|h|HH|H|KK|K|kk|k|mm|m|ss|s|aa|a|SSS|SS|S|zzzz|zzz|zz|z|v|ZZZ|ZZ|Z|XXX|XX|X|VV|GGGGG|GGGG|GGG|GG|G/g;\n  public static readonly _ZULU = 'zulu';\n  public static readonly _LOCAL = 'local';\n  public static readonly _AUTO = 'auto';\n  public static readonly _INVARIANT = 'invariant';\n  public static readonly _OFFSET = 'offset';\n  public static readonly _ALNUM_REGEXP = '(\\\\D+|\\\\d\\\\d?\\\\D|\\\\d\\\\d?|\\\\D+\\\\d\\\\d?)';\n  public static readonly _NON_DIGIT_REGEXP = '(\\\\D+|\\\\D+\\\\d\\\\d?)';\n  public static readonly _NON_DIGIT_OPT_REGEXP = '(\\\\D*)';\n  public static readonly _STR_REGEXP = '(.+?)';\n  public static readonly _TWO_DIGITS_REGEXP = '(\\\\d\\\\d?)';\n  public static readonly _THREE_DIGITS_REGEXP = '(\\\\d{1,3})';\n  public static readonly _FOUR_DIGITS_REGEXP = '(\\\\d{1,4})';\n  public static readonly _SLASH_REGEXP = '(\\\\/)';\n\n  public static readonly _PROPERTIES_MAP = {\n    MMM: {\n      token: 'months',\n      style: 'format',\n      mLen: 'abbreviated',\n      matchIndex: 0,\n      key: 'month',\n      value: 'short',\n      regExp: NativeDateTimeConstants._ALNUM_REGEXP\n    },\n    MMMM: {\n      token: 'months',\n      style: 'format',\n      mLen: 'wide',\n      matchIndex: 0,\n      key: 'month',\n      value: 'long',\n      regExp: NativeDateTimeConstants._ALNUM_REGEXP\n    },\n    MMMMM: {\n      token: 'months',\n      style: 'format',\n      mLen: 'narrow',\n      matchIndex: 0,\n      key: 'month',\n      value: 'narrow',\n      regExp: NativeDateTimeConstants._ALNUM_REGEXP\n    },\n    LLL: {\n      token: 'months',\n      style: 'stand-alone',\n      mLen: 'abbreviated',\n      matchIndex: 1,\n      key: 'month',\n      value: 'short',\n      regExp: NativeDateTimeConstants._ALNUM_REGEXP\n    },\n    LLLL: {\n      token: 'months',\n      style: 'stand-alone',\n      mLen: 'wide',\n      matchIndex: 1,\n      key: 'month',\n      value: 'long',\n      regExp: NativeDateTimeConstants._ALNUM_REGEXP\n    },\n    LLLLL: {\n      token: 'months',\n      style: 'stand-alone',\n      mLen: 'narrow',\n      matchIndex: 1,\n      key: 'month',\n      value: 'narrow',\n      regExp: NativeDateTimeConstants._ALNUM_REGEXP\n    },\n    E: {\n      token: 'days',\n      style: 'format',\n      dLen: 'abbreviated',\n      matchIndex: 0,\n      key: 'weekday',\n      value: 'short',\n      regExp: NativeDateTimeConstants._NON_DIGIT_REGEXP\n    },\n    EE: {\n      token: 'days',\n      style: 'format',\n      dLen: 'abbreviated',\n      matchIndex: 0,\n      key: 'weekday',\n      value: 'short',\n      regExp: NativeDateTimeConstants._NON_DIGIT_REGEXP\n    },\n    EEE: {\n      token: 'days',\n      style: 'format',\n      dLen: 'abbreviated',\n      matchIndex: 0,\n      key: 'weekday',\n      value: 'short',\n      regExp: NativeDateTimeConstants._NON_DIGIT_REGEXP\n    },\n    EEEE: {\n      token: 'days',\n      style: 'format',\n      dLen: 'wide',\n      matchIndex: 0,\n      key: 'weekday',\n      value: 'long',\n      regExp: NativeDateTimeConstants._NON_DIGIT_REGEXP\n    },\n    EEEEE: {\n      token: 'days',\n      style: 'format',\n      dLen: 'narrow',\n      matchIndex: 0,\n      key: 'weekday',\n      value: 'narrow',\n      regExp: NativeDateTimeConstants._NON_DIGIT_REGEXP\n    },\n    c: {\n      token: 'days',\n      style: 'stand-alone',\n      dLen: 'abbreviated',\n      matchIndex: 1,\n      key: 'weekday',\n      value: 'short',\n      regExp: NativeDateTimeConstants._NON_DIGIT_REGEXP\n    },\n    cc: {\n      token: 'days',\n      style: 'stand-alone',\n      dLen: 'abbreviated',\n      matchIndex: 1,\n      key: 'weekday',\n      value: 'short',\n      regExp: NativeDateTimeConstants._NON_DIGIT_REGEXP\n    },\n    ccc: {\n      token: 'days',\n      style: 'stand-alone',\n      dLen: 'abbreviated',\n      matchIndex: 1,\n      key: 'weekday',\n      value: 'short',\n      regExp: NativeDateTimeConstants._NON_DIGIT_REGEXP\n    },\n    cccc: {\n      token: 'days',\n      style: 'stand-alone',\n      dLen: 'wide',\n      matchIndex: 1,\n      key: 'weekday',\n      value: 'long',\n      regExp: NativeDateTimeConstants._NON_DIGIT_REGEXP\n    },\n    ccccc: {\n      token: 'days',\n      style: 'stand-alone',\n      dLen: 'narrow',\n      matchIndex: 1,\n      key: 'weekday',\n      value: 'narrow',\n      regExp: NativeDateTimeConstants._NON_DIGIT_REGEXP\n    },\n    h: {\n      token: 'time',\n      timePart: 'hour',\n      start1: 0,\n      end1: 11,\n      start2: 1,\n      end2: 12,\n      key: 'hour',\n      value: 'numeric',\n      regExp: NativeDateTimeConstants._TWO_DIGITS_REGEXP\n    },\n    hh: {\n      token: 'time',\n      timePart: 'hour',\n      start1: 0,\n      end1: 11,\n      start2: 1,\n      end2: 12,\n      key: 'hour',\n      value: '2-digit',\n      regExp: NativeDateTimeConstants._TWO_DIGITS_REGEXP\n    },\n    K: {\n      token: 'time',\n      timePart: 'hour',\n      start1: 0,\n      end1: 12,\n      start2: 0,\n      end2: 12,\n      key: 'hour',\n      value: 'numeric',\n      regExp: NativeDateTimeConstants._TWO_DIGITS_REGEXP\n    },\n    KK: {\n      token: 'time',\n      timePart: 'hour',\n      start1: 0,\n      end1: 12,\n      start2: 0,\n      end2: 12,\n      key: 'hour',\n      value: '2-digit',\n      regExp: NativeDateTimeConstants._TWO_DIGITS_REGEXP\n    },\n    H: {\n      token: 'time',\n      timePart: 'hour',\n      start1: 0,\n      end1: 23,\n      start2: 0,\n      end2: 23,\n      key: 'hour',\n      value: 'numeric',\n      regExp: NativeDateTimeConstants._TWO_DIGITS_REGEXP\n    },\n    HH: {\n      token: 'time',\n      timePart: 'hour',\n      start1: 0,\n      end1: 23,\n      start2: 0,\n      end2: 23,\n      key: 'hour',\n      value: '2-digit',\n      regExp: NativeDateTimeConstants._TWO_DIGITS_REGEXP\n    },\n    k: {\n      token: 'time',\n      timePart: 'hour',\n      start1: 0,\n      end1: 24,\n      start2: 0,\n      end2: 24,\n      key: 'hour',\n      value: 'numeric',\n      regExp: NativeDateTimeConstants._TWO_DIGITS_REGEXP\n    },\n    kk: {\n      token: 'time',\n      timePart: 'hour',\n      start1: 0,\n      end1: 24,\n      start2: 0,\n      end2: 24,\n      key: 'hour',\n      value: '2-digit',\n      regExp: NativeDateTimeConstants._TWO_DIGITS_REGEXP\n    },\n    m: {\n      token: 'time',\n      timePart: 'minute',\n      start1: 0,\n      end1: 59,\n      start2: 0,\n      end2: 59,\n      key: 'minute',\n      value: 'numeric',\n      regExp: NativeDateTimeConstants._TWO_DIGITS_REGEXP\n    },\n    mm: {\n      token: 'time',\n      timePart: 'minute',\n      start1: 0,\n      end1: 59,\n      start2: 0,\n      end2: 59,\n      key: 'minute',\n      value: '2-digit',\n      regExp: NativeDateTimeConstants._TWO_DIGITS_REGEXP\n    },\n    s: {\n      token: 'time',\n      timePart: 'second',\n      start1: 0,\n      end1: 59,\n      start2: 0,\n      end2: 59,\n      key: 'second',\n      value: 'numeric',\n      regExp: NativeDateTimeConstants._TWO_DIGITS_REGEXP\n    },\n    ss: {\n      token: 'time',\n      timePart: 'second',\n      start1: 0,\n      end1: 59,\n      start2: 0,\n      end2: 59,\n      key: 'second',\n      value: '2-digit',\n      regExp: NativeDateTimeConstants._TWO_DIGITS_REGEXP\n    },\n    S: {\n      token: 'time',\n      timePart: 'millisec',\n      start1: 0,\n      end1: 999,\n      start2: 0,\n      end2: 999,\n      key: 'millisecond',\n      value: 'numeric',\n      regExp: NativeDateTimeConstants._THREE_DIGITS_REGEXP\n    },\n    SS: {\n      token: 'time',\n      timePart: 'millisec',\n      start1: 0,\n      end1: 999,\n      start2: 0,\n      end2: 999,\n      key: 'millisecond',\n      value: 'numeric',\n      regExp: NativeDateTimeConstants._THREE_DIGITS_REGEXP\n    },\n    SSS: {\n      token: 'time',\n      timePart: 'millisec',\n      start1: 0,\n      end1: 999,\n      start2: 0,\n      end2: 999,\n      key: 'millisecond',\n      value: 'numeric',\n      regExp: NativeDateTimeConstants._THREE_DIGITS_REGEXP\n    },\n    d: {\n      token: 'dayOfMonth',\n      key: 'day',\n      value: 'numeric',\n      getPartIdx: 2,\n      regExp: NativeDateTimeConstants._TWO_DIGITS_REGEXP\n    },\n    dd: {\n      token: 'dayOfMonth',\n      key: 'day',\n      value: '2-digit',\n      getPartIdx: 2,\n      regExp: NativeDateTimeConstants._TWO_DIGITS_REGEXP\n    },\n    M: {\n      token: 'monthIndex',\n      key: 'month',\n      value: 'numeric',\n      getPartIdx: 1,\n      regExp: NativeDateTimeConstants._TWO_DIGITS_REGEXP\n    },\n    MM: {\n      token: 'monthIndex',\n      key: 'month',\n      value: '2-digit',\n      getPartIdx: 1,\n      regExp: NativeDateTimeConstants._TWO_DIGITS_REGEXP\n    },\n    L: {\n      token: 'monthIndex',\n      key: 'month',\n      value: 'numeric',\n      getPartIdx: 1,\n      regExp: NativeDateTimeConstants._TWO_DIGITS_REGEXP\n    },\n    LL: {\n      token: 'monthIndex',\n      key: 'month',\n      value: '2-digit',\n      getPartIdx: 1,\n      regExp: NativeDateTimeConstants._TWO_DIGITS_REGEXP\n    },\n    y: {\n      token: 'year',\n      key: 'year',\n      value: 'numeric',\n      regExp: NativeDateTimeConstants._FOUR_DIGITS_REGEXP\n    },\n    yy: {\n      token: 'year',\n      key: 'year',\n      value: '2-digit',\n      regExp: NativeDateTimeConstants._TWO_DIGITS_REGEXP\n    },\n    yyyy: {\n      token: 'year',\n      key: 'year',\n      value: 'numeric',\n      regExp: NativeDateTimeConstants._FOUR_DIGITS_REGEXP\n    },\n    a: {\n      token: 'ampm',\n      key: 'dayPeriod',\n      value: undefined,\n      regExp: NativeDateTimeConstants._WORD_REGEXP\n    },\n    z: {\n      token: 'tzAbbrev',\n      key: 'timeZoneName',\n      value: 'short',\n      regExp: NativeDateTimeConstants._STR_REGEXP\n    },\n    v: {\n      token: 'tzAbbrev',\n      key: 'timeZoneName',\n      value: 'short',\n      regExp: NativeDateTimeConstants._STR_REGEXP\n    },\n    zz: {\n      token: 'tzAbbrev',\n      key: 'timeZoneName',\n      value: 'short',\n      regExp: NativeDateTimeConstants._STR_REGEXP\n    },\n    zzz: {\n      token: 'tzAbbrev',\n      key: 'timeZoneName',\n      value: 'short',\n      regExp: NativeDateTimeConstants._STR_REGEXP\n    },\n    zzzz: {\n      token: 'tzFull',\n      key: 'timeZoneName',\n      value: 'long',\n      regExp: NativeDateTimeConstants._STR_REGEXP\n    },\n    Z: {\n      token: 'tzhm',\n      key: 'tzhm',\n      value: 'short',\n      regExp: NativeDateTimeConstants._STR_REGEXP,\n      type: 'tzOffset'\n    },\n    ZZ: {\n      token: 'tzhm',\n      key: 'tzhm',\n      value: 'short',\n      regExp: NativeDateTimeConstants._STR_REGEXP,\n      type: 'tzOffset'\n    },\n    ZZZ: {\n      token: 'tzhm',\n      key: 'tzhm',\n      value: 'short',\n      regExp: NativeDateTimeConstants._STR_REGEXP,\n      type: 'tzOffset'\n    },\n    X: {\n      token: 'tzh',\n      key: 'tzh',\n      value: 'short',\n      regExp: NativeDateTimeConstants._STR_REGEXP,\n      type: 'tzOffset'\n    },\n    XX: {\n      token: 'tzhm',\n      key: 'tzhm',\n      value: 'short',\n      regExp: NativeDateTimeConstants._STR_REGEXP,\n      type: 'tzOffset'\n    },\n    XXX: {\n      token: 'tzhsepm',\n      key: 'tzhsepm',\n      value: 'short',\n      regExp: NativeDateTimeConstants._STR_REGEXP,\n      type: 'tzOffset'\n    },\n    VV: {\n      token: 'tzid',\n      key: 'tzid',\n      value: 'short',\n      regExp: NativeDateTimeConstants._STR_REGEXP,\n      type: 'tzOffset'\n    },\n    G: {\n      token: 'era',\n      key: 'era',\n      value: 'eraAbbr',\n      regExp: NativeDateTimeConstants._NON_DIGIT_REGEXP\n    },\n    GG: {\n      token: 'era',\n      key: 'era',\n      value: 'eraAbbr',\n      regExp: NativeDateTimeConstants._NON_DIGIT_REGEXP\n    },\n    GGG: {\n      token: 'era',\n      key: 'era',\n      value: 'eraAbbr',\n      regExp: NativeDateTimeConstants._NON_DIGIT_REGEXP\n    },\n    GGGG: {\n      token: 'era',\n      key: 'era',\n      value: 'eraName',\n      regExp: NativeDateTimeConstants._NON_DIGIT_REGEXP\n    },\n    GGGGG: {\n      token: 'era',\n      key: 'era',\n      value: 'eraNarrow',\n      regExp: NativeDateTimeConstants._NON_DIGIT_REGEXP\n    },\n    '/': {\n      token: 'slash',\n      regExp: NativeDateTimeConstants._SLASH_REGEXP\n    }\n  };\n\n  public static readonly FRACTIONAL_SECOND_MAP = {\n    a: {\n      key: 'dayPeriod',\n      token: 'dayPeriod',\n      value: 'narrow'\n    },\n    SSS: {\n      key: 'fractionalSecondDigits',\n      token: 'fractionalSecond',\n      value: 3\n    },\n    SS: {\n      key: 'fractionalSecondDigits',\n      token: 'fractionalSecond',\n      value: 2\n    },\n    S: {\n      key: 'fractionalSecondDigits',\n      token: 'fractionalSecond',\n      value: 1\n    }\n  };\n  // Map between tokens length and options\n  public static readonly _tokenMap = {\n    era: { short: 'GGG', long: 'GGGG', narrow: 'GGGGG' },\n    month: { short: 'MMM', long: 'MMMM', narrow: 'MMMMM', numeric: 'M', '2-digit': 'MM' },\n    weekday: { short: 'EEE', long: 'EEEE', narrow: 'EEEEE' },\n    year: { numeric: 'y', '2-digit': 'yy' },\n    day: { numeric: 'd', '2-digit': 'dd' },\n    hour: { numeric: 'h', '2-digit': 'hh' },\n    minute: { numeric: 'm', '2-digit': 'mm' },\n    second: { numeric: 's', '2-digit': 'ss' },\n    fractionalSecond: { 1: 'S', 2: 'SS', 3: 'SSS' },\n    timeZoneName: { short: 'z', long: 'zzzz' }\n  };\n  // Map between tokens and timeStyle and dateStyle\n  // Always set year to y, hour to h, minute to m, and second to s\n  // We need to get the pattern from the options. It is only needed by parse,\n  // prase does not care of the difference between h an hh, y and yy because\n  // they are all numeric. so 2021/09/01 is equivalent to 21/9/1 because the\n  // pattern is (\\d)+/(\\d)+/(\\(d)+ matches both of inputs\n  public static readonly _dateTimeFormats = {\n    dateStyle: {\n      full: { year: 'y', month_s: 'MM', month_m: 'MMMM', weekday: 'EEEE', day: 'd' },\n      long: { year: 'y', month_s: 'MM', month_m: 'MMMM', day: 'd' },\n      medium: { year: 'y', month_s: 'MM', month_m: 'MMM', day: 'd' },\n      short: { year: 'y', month_s: 'M', month_m: 'MMM', day: 'd' }\n    },\n    timeStyle: {\n      full: { hour: 'h', minute: 'mm', second: 'ss', timeZoneName: 'zzzz' },\n      long: { hour: 'h', minute: 'mm', second: 'ss', timeZoneName: 'z' },\n      medium: { hour: 'h', minute: 'mm', second: 'ss' },\n      short: { hour: 'h', minute: 'mm' }\n    }\n  };\n  // letters a-z and A-Z are reserved for date-time tokens in the pattern\n  // they need to be surrounded by single quote if they are not a token.\n  // for example at should appear as 'at' in the pattern\n  public static readonly _ALPHA_REGEXP = /([a-zA-Z]+)/;\n  public static readonly _HOUR12_REGEXP = /h/g;\n  public static readonly _hourCycleMap = {\n    h12: 'h',\n    h23: 'H',\n    h11: 'K',\n    h24: 'k'\n  };\n  // zh-TW locales have different symbols for pm depending on the time.\n  // The following entries are noon, after noon, and evening\n  public static readonly _zh_tw_locales = ['zh-TW', 'zh-Hant', 'zh-Hant-TW'];\n  public static readonly _zh_tw_pm_symbols = ['\\u4e2d\\u5348', '\\u4e0b\\u5348', '\\u665a\\u4e0a'];\n}\n","/**\n * @license\n * Copyright (c) 2004 %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { NativeDateTimeResolvedOptions } from './NativeDateTimeOptions';\n\n/**\n * Date time utilities.\n */\n\nconst regexTrim = /^\\s+|\\s+$|\\u200f|\\u200e/g;\nconst regexTrimNumber = /\\s+|\\u200f|\\u200e/g;\nconst regexTrimRightZeros = /0+$/g;\nconst zeros = ['0', '00', '000'];\n\n// ISO 8601 string accepted values:\n// -date only: YYYY or YYYY-MM or YYYY-MM-dd\n// -time only without timezone: Thh:mm or Thh:mm:ss or Thh:mm:ss.SSS\n// -time only with timezone: any of the time values above followed by any of the following:\n// Z or +/-hh:mm or +/-hhmm or +/-hh\n// -date time: any of the date values followed by any of the time values\nexport const _ISO_DATE_REGEXP =\n  /^[+-]?\\d{4}(?:-\\d{2}(?:-\\d{2})?)?(?:T\\d{2}:\\d{2}(?::\\d{2}(?:\\.\\d{1,3})?)?(Z|[+-]\\d{2}(?::?\\d{2})?)?)?$|^T\\d{2}:\\d{2}(?::\\d{2}(?:\\.\\d{1,3})?)?(Z|[+-]\\d{2}(?::?\\d{2})?)?$/;\n\nconst _ISO_DATE_ONLY_REGEXP = /^[+-]?\\d{4}-\\d{2}-\\d{2}$/;\n\n/**\n * Returns true if the value represents a date-only ISO string.\n *\n * @param {string} value\n * @returns true if the string represents a date-only ISO string\n */\nexport function isDateOnlyIsoString(value?: string | null) {\n  // If value is undefined/null, returns true.\n  // If value is empty or blank string, returns false.\n  // Otherwise checks value against the regexp.\n  const isValid =\n    value === undefined || value === null\n      ? true\n      : value.trim().length > 0\n      ? _ISO_DATE_ONLY_REGEXP.test(value.trim())\n      : false;\n  return isValid;\n}\n\nexport function startsWith(value: string, pattern: string) {\n  return value.indexOf(pattern) === 0;\n}\n\nexport function trim(value: string) {\n  return (value + '').replace(regexTrim, '');\n}\n\nexport function trimRightZeros(value: string) {\n  return (value + '').replace(regexTrimRightZeros, '');\n}\n\nexport function trimNumber(value: string) {\n  const s = (value + '').replace(regexTrimNumber, '');\n  return s;\n}\n\nexport function toUpper(value: string) {\n  // \"he-IL\" has non-breaking space in weekday names.\n  return value.split('\\u00A0').join(' ').toUpperCase();\n}\n\nexport function padZeros(num: number, c: number) {\n  let s = num + '';\n  let isNegative = false;\n  if (num < 0) {\n    s = s.substr(1);\n    isNegative = true;\n  }\n  if (c > 1 && s.length < c) {\n    s = zeros[c - 2] + s;\n    s = s.substr(s.length - c, c);\n  }\n  if (isNegative) {\n    s = '-' + s;\n  }\n  return s;\n}\n\nexport function zeroPad(str: string, count: number, left: boolean) {\n  let result = '' + str;\n\n  for (let l = result.length; l < count; l += 1) {\n    result = left ? '0' + result : result + '0';\n  }\n  return result;\n}\n\nfunction _throwInvalidISOStringRange(\n  isoStr: string,\n  name: string,\n  displayValue: string | number,\n  displayLow: number,\n  displayHigh: number\n) {\n  const msg =\n    'The string ' +\n    isoStr +\n    ' is not a valid ISO 8601 string: ' +\n    displayValue +\n    ' is out of range.  Enter a value between ' +\n    displayLow +\n    ' and ' +\n    displayHigh +\n    ' for ' +\n    name;\n\n  const errorInfo = {\n    cause: {\n      code: 'isoStringOutOfRange',\n      parameterMap: {\n        isoStr: isoStr,\n        value: displayValue,\n        minValue: displayLow,\n        maxValue: displayHigh,\n        propertyName: name\n      }\n    }\n  };\n\n  const rangeError = new (RangeError as any)(msg, errorInfo);\n  throw rangeError;\n}\n\nfunction _throwInvalidISOStringSyntax(str: string) {\n  const msg = 'The string ' + str + ' is not a valid ISO 8601 string syntax.';\n  const errorInfo = {\n    cause: {\n      code: 'invalidISOString',\n      parameterMap: {\n        isoStr: str\n      }\n    }\n  };\n  const e = new (Error as any)(msg, errorInfo);\n  throw e;\n}\n\n/**\n * <p>Returns a local ISO string provided a Date object.\n * This method can be used to convert a moment in time or a local ISO string into\n * a local ISO string. It can also be used to convert any Date object into local ISO\n * string.</p>\n * Examples below are where the local (user's system) time zone is UTC-06:00<br>\n * dateToLocalIso(new Date('2021-06-04T00:00:00-04:00')); -->'2021-06-03T22:00:00'<br>\n * dateToLocalIso(new Date('2021-06-04T02:30:00Z')); -->'2021-06-03T20:30:00'<br>\n * In this example the input ISO string is local, the output is the same:<br>\n * dateToLocalIso(new Date('2021-06-04T02:30:00')); -->'2021-06-04T02:30:00'<br>\n * In this example we just want to convert a Date object:<br>\n * dateToLocalIso(new Date());<br>\n */\nexport function dateToLocalIso(_date: Date | number) {\n  let date = _date;\n  if (typeof date === 'number') {\n    date = new Date(date);\n  }\n  let isoStr =\n    padZeros(date.getFullYear(), 4) +\n    '-' +\n    padZeros(date.getMonth() + 1, 2) +\n    '-' +\n    padZeros(date.getDate(), 2) +\n    'T' +\n    padZeros(date.getHours(), 2) +\n    ':' +\n    padZeros(date.getMinutes(), 2) +\n    ':' +\n    padZeros(date.getSeconds(), 2);\n  if (date.getMilliseconds() > 0) {\n    isoStr += '.' + trimRightZeros(padZeros(date.getMilliseconds(), 3));\n  }\n  return isoStr;\n}\n\nexport function isLeapYear(y: number) {\n  if (y % 400 === 0) {\n    return true;\n  } else if (y % 100 === 0) {\n    return false;\n  } else if (y % 4 === 0) {\n    return true;\n  }\n  return false;\n}\n\n// Get days in month depending on month and leap year\nexport function getDaysInMonth(y: number, m: number) {\n  switch (m) {\n    case 0:\n    case 2:\n    case 4:\n    case 6:\n    case 7:\n    case 9:\n    case 11:\n      return 31;\n    case 1:\n      if (isLeapYear(y)) {\n        return 29;\n      }\n      return 28;\n    default:\n      return 30;\n  }\n}\n\nexport function IsoStrParts(isoString: string) {\n  const tst = _ISO_DATE_REGEXP.test(isoString);\n  if (tst === false) {\n    _throwInvalidISOStringSyntax(isoString);\n  }\n  const splitted = isoString.split('T');\n  const tIndex = isoString.indexOf('T');\n  const today = new Date();\n  let i;\n  let isBC = false;\n  const datetime = [today.getFullYear(), today.getMonth() + 1, today.getDate(), 0, 0, 0, 0];\n\n  if (splitted[0] !== '') {\n    // contains date portion\n    // test if date is BC, year is negative\n    if (startsWith(splitted[0], '-')) {\n      splitted[0] = splitted[0].slice(1);\n      isBC = true;\n    }\n    const dateSplitted = splitted[0].split('-');\n    for (i = 0; i < dateSplitted.length; i++) {\n      const val = parseInt(dateSplitted[i], 10);\n      // validate month\n      if (i === 1) {\n        if (val < 1 || val > 12) {\n          _throwInvalidISOStringRange(isoString, 'month', val, 1, 12);\n        }\n      }\n      // validate day\n      if (i === 2) {\n        const nbDays = getDaysInMonth(datetime[0], datetime[1] - 1);\n        if (val < 1 || val > nbDays) {\n          _throwInvalidISOStringRange(isoString, 'day', val, 1, nbDays);\n        }\n      }\n      datetime[i] = val;\n    }\n    if (isBC) {\n      datetime[0] = -datetime[0];\n    }\n  }\n\n  if (tIndex !== -1) {\n    const milliSecSplitted = splitted[1].split('.'); // contain millseconds\n    const timeSplitted = milliSecSplitted[0].split(':'); // contain hours, minutes, seconds\n\n    for (i = 0; i < timeSplitted.length; i++) {\n      const tVal = parseInt(timeSplitted[i], 10);\n      // validate hour\n      if (i === 0) {\n        if (tVal < 0 || tVal > 24) {\n          _throwInvalidISOStringRange(isoString, 'hour', tVal, 0, 24);\n        }\n      }\n      // validate minute\n      if (i === 1) {\n        if (tVal < 0 || tVal > 59) {\n          _throwInvalidISOStringRange(isoString, 'minute', tVal, 0, 59);\n        }\n      }\n      // validate second\n      if (i === 2) {\n        if (tVal < 0 || tVal > 59) {\n          _throwInvalidISOStringRange(isoString, 'second', tVal, 0, 59);\n        }\n      }\n      datetime[3 + i] = tVal;\n    }\n\n    if (milliSecSplitted.length === 2 && milliSecSplitted[1]) {\n      datetime[6] = parseInt(zeroPad(milliSecSplitted[1], 3, false), 10);\n    }\n  }\n  return datetime;\n}\n\nfunction _toBoolean(value: any) {\n  if (typeof value === 'string') {\n    const s = value.toLowerCase().trim();\n    switch (s) {\n      case 'true':\n      case '1':\n        return true;\n      case 'false':\n      case '0':\n        return false;\n      default:\n        return value;\n    }\n  }\n  return value;\n}\n\n// Return a function getOption.\n// The getOption function extracts the value of the property named\n// property from the provided options object, converts it to the required type,\n// checks whether it is one of a List of allowed values, and fills in a\n// fallback value if necessary.\nexport function getGetOption(options: NativeDateTimeResolvedOptions, getOptionCaller: string) {\n  if (options === undefined) {\n    throw new Error('Internal ' + getOptionCaller + ' error. Default options missing.');\n  }\n\n  const getOption = function (property: any, type: any, values: any, defaultValue: any) {\n    if ((options as any)[property] !== undefined) {\n      let value = (options as any)[property];\n      switch (type) {\n        case 'boolean':\n          value = _toBoolean(value);\n          break;\n        case 'string':\n          value = String(value);\n          break;\n        case 'number':\n          value = Number(value);\n          break;\n        default:\n          throw new Error('Internal error. Wrong value type.');\n      }\n      if (values !== undefined && values.indexOf(value) === -1) {\n        const expectedValues = [];\n        for (let i = 0; i < values.length; i++) {\n          expectedValues.push(values[i]);\n        }\n        const msg =\n          \"The value '\" +\n          (options as any)[property] +\n          \"' is out of range for '\" +\n          getOptionCaller +\n          \"' options property '\" +\n          property +\n          \"'. Valid values: \" +\n          expectedValues;\n        const rangeError = new RangeError(msg);\n        const errorInfo = {\n          errorCode: 'optionOutOfRange',\n          parameterMap: {\n            propertyName: property,\n            propertyValue: (options as any)[property],\n            propertyValueValid: expectedValues,\n            caller: getOptionCaller\n          }\n        };\n        (rangeError as any).errorInfo = errorInfo;\n        throw rangeError;\n      }\n\n      return value;\n    }\n    return defaultValue;\n  };\n\n  return getOption;\n}\n\nexport function partsToIsoString(parts: any) {\n  let isoStr =\n    padZeros(parts[0], 4) +\n    '-' +\n    padZeros(parts[1], 2) +\n    '-' +\n    padZeros(parts[2], 2) +\n    'T' +\n    padZeros(parts[3], 2) +\n    ':' +\n    padZeros(parts[4], 2) +\n    ':' +\n    padZeros(parts[5], 2);\n  if (parts[6] > 0) {\n    isoStr += '.' + trimRightZeros(padZeros(parts[6], 3));\n  }\n  return isoStr;\n}\n\n/**\n * Returns a local Date object from a local ISO string. This method is only meant\n * to work with local ISO strings. If the input ISO string contain Z or offset,\n * they will be ignored.\n * @param {string} isoString\n * @memberof oj.OraI18nUtils\n * @method isoToLocalDate\n */\nexport function isoToLocalDate(isoString: string) {\n  if (!isoString || typeof isoString !== 'string') {\n    return null;\n  }\n  return _isoToLocalDateIgnoreTimezone(isoString);\n}\n\nfunction _isoToLocalDateIgnoreTimezone(isoString: string) {\n  const datetime = IsoStrParts(isoString);\n  const date = new Date(\n    datetime[0],\n    datetime[1] - 1,\n    datetime[2],\n    datetime[3],\n    datetime[4],\n    datetime[5],\n    datetime[6]\n  );\n  // As per the documentation:\n  // new Date(year, monthIndex [, day [, hours [, minutes [, seconds [, milliseconds]]]]]);\n  // year - Integer value representing the year and\n  // values from 0 to 99 map to the years 1900 to 1999; all other values are the actual year.\n  // Use Date.prototype.setFullYear to create dates between the years 0 and 99.\n  date.setFullYear(datetime[0]);\n  return date;\n}\n\nexport function getISOStrFormatInfo(isoStr: string) {\n  const res: any = {\n    format: null,\n    dateTime: null,\n    timeZone: '',\n    isoStrParts: null\n  };\n  const exe: any = _ISO_DATE_REGEXP.exec(isoStr);\n\n  if (exe === null) {\n    _throwInvalidISOStringSyntax(isoStr);\n  }\n  if (exe && exe[1] === undefined && exe[2] === undefined) {\n    res.format = 'local';\n    res.dateTime = isoStr;\n    res.isoStrParts = IsoStrParts(res.dateTime);\n    return res;\n  }\n  res.timeZone = exe[1] !== undefined ? exe[1] : exe[2];\n  if (res.timeZone === 'Z') {\n    res.format = 'zulu';\n  } else {\n    res.format = 'offset';\n  }\n  const isoStrLen = isoStr.length;\n  const timeZoneLen = res.timeZone.length;\n  res.dateTime = isoStr.substring(0, isoStrLen - timeZoneLen);\n  res.isoStrParts = IsoStrParts(res.dateTime);\n  return res;\n}\n\nexport function getTimeStringFromOffset(\n  prefix: string,\n  offset: number,\n  reverseSign: boolean,\n  alwaysMinutes: boolean\n) {\n  const isNegative = reverseSign ? offset > 0 : offset < 0;\n  const absOffset = Math.abs(offset);\n  let hours: any = Math.floor(absOffset / 60);\n  const minutes: any = absOffset % 60;\n  const sign = isNegative ? '-' : '+';\n\n  if (alwaysMinutes) {\n    hours = zeroPad(hours, 2, true);\n  }\n  let str = prefix + sign + hours;\n  if (minutes > 0 || alwaysMinutes) {\n    str += ':' + zeroPad(minutes, 2, true);\n  }\n  return str;\n}\n","/**\n * @license\n * Copyright (c) 2004 %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { CalendarNodeType } from './CalendarUtils';\nimport { DateDef } from './ISODateTimezoneOffset';\nimport { FormatParseError, FormatParseErrorOptions } from '../UNSAFE_IntlFormatParse';\nimport { getISODateOffset } from './ISODateTimezoneOffset';\n// import { Logger } from '../utils/UNSAFE_logger';\nimport { NativeDateTimeConstants } from './NativeDateTimeConstants';\nimport { NativeDateTimeOptions } from './NativeDateTimeOptions';\nimport { NativeDateTimeResolvedOptions } from './NativeDateTimeOptions';\n\nimport * as LocalOraI18nUtils from './dateTimeUtils';\n\ninterface ParsedObjectType {\n  value: string;\n  warning: string;\n}\n\ninterface RangeType {\n  name: string;\n  value: number;\n  low: number;\n  high: number;\n  displayValue: number;\n  displayLow: number;\n  displayHigh: number;\n}\n// cache locale system time zone\nlet localSystemTimeZone: string | null = null;\n\nexport class NativeParserImpl {\n  public static parseImpl(\n    str: string,\n    pattern: string,\n    resOptions: NativeDateTimeResolvedOptions,\n    cal: CalendarNodeType\n  ): ParsedObjectType {\n    let dtStyle = 0;\n    // First try if str is an iso 8601 string\n    const testIsoStr = LocalOraI18nUtils._ISO_DATE_REGEXP.test(str);\n    let parsedIsoStr = '';\n    let isoStrInfo = null;\n    let res: any;\n    if (testIsoStr === true) {\n      parsedIsoStr = str;\n      dtStyle = this._isoStrDateTimeStyle(str);\n    } else {\n      dtStyle = this._dateTimeStyle(resOptions);\n      res = this._parseExact(str, pattern, resOptions, cal);\n      parsedIsoStr = res.value;\n    }\n    isoStrInfo = LocalOraI18nUtils.getISOStrFormatInfo(parsedIsoStr);\n    if (resOptions.timeZone !== undefined && isoStrInfo.format !== NativeDateTimeConstants._LOCAL) {\n      this._adjustHours(isoStrInfo, resOptions);\n    }\n    parsedIsoStr = this._createParseISOStringFromDate(dtStyle, isoStrInfo, resOptions);\n    if (res === undefined) {\n      res = { value: parsedIsoStr, warning: null };\n    } else {\n      res.value = parsedIsoStr;\n      res.warning = null;\n    }\n    // If the returned ISO string is date-time and isoStrFormat is local,\n    // log a warning saying that local is not supported for date-time iso strings\n    // and return offset instead\n    if (dtStyle === 2 && resOptions.isoStrFormat === NativeDateTimeConstants._LOCAL) {\n      // Disable warning since it causes noise in test runs.\n      // TODO: Re-enable once JET-59083 is fixed.\n      //Logger.warn(\n      //  'isoStrFormat was set to local for date-time ISO string. local was ignored and parse returned an ISO string with offset.'\n      //);\n    }\n    return res;\n  }\n  // appends pre- and post- token match strings while removing escaped\n  // characters.\n  // Returns a single quote count which is used to determine if the\n  // token occurs\n  // in a string literal.\n  private static _appendPreOrPostMatch(preMatch: string, strings: Array<string>): number {\n    let quoteCount = 0;\n    let escaped = false;\n    for (let i = 0, il = preMatch.length; i < il; i++) {\n      const c = preMatch.charAt(i);\n      switch (c) {\n        case \"'\":\n          if (escaped) {\n            strings.push(\"'\");\n          } else {\n            quoteCount += 1;\n          }\n          escaped = false;\n          break;\n        case '\\\\':\n          if (escaped) {\n            strings.push('\\\\');\n          }\n          escaped = !escaped;\n          break;\n        default:\n          strings.push(c);\n          escaped = false;\n          break;\n      }\n    }\n    return quoteCount;\n  }\n\n  private static _validateRange(range: RangeType) {\n    if (range.value < range.low || range.value > range.high) {\n      const msg =\n        range.displayValue +\n        ' is out of range.  Enter a value between ' +\n        range.displayLow +\n        ' and ' +\n        range.displayHigh +\n        ' for ' +\n        range.name;\n\n      const errorInfo: FormatParseErrorOptions = {\n        cause: {\n          code: 'datetimeOutOfRange',\n          parameterMap: {\n            value: range.displayValue,\n            minValue: range.displayLow,\n            maxValue: range.displayHigh,\n            propertyName: range.name\n          }\n        }\n      };\n      const rangeError = new (RangeError as any)(msg, errorInfo);\n      throw rangeError;\n    }\n  }\n\n  // Throw an exception if date-time pattern is invalid\n  private static _throwInvalidDateFormat(\n    format: string,\n    options: NativeDateTimeOptions | NativeDateTimeResolvedOptions,\n    m: string\n  ) {\n    const isDate =\n      options.year !== undefined ||\n      options.month !== undefined ||\n      options.weekday !== undefined ||\n      options.day !== undefined;\n    const isTime =\n      options.hour !== undefined || options.minute !== undefined || options.second !== undefined;\n\n    let samplePattern = '';\n    if (isDate && isTime) {\n      samplePattern = 'MM/dd/yy hh:mm:ss a';\n    } else if (isDate) {\n      samplePattern = 'MM/dd/yy';\n    } else {\n      samplePattern = 'hh:mm:ss a';\n    }\n\n    const msg =\n      'Unexpected character(s) ' +\n      m +\n      ' encountered in the pattern \"' +\n      format +\n      ' An example of a valid pattern is \"' +\n      samplePattern +\n      '\".';\n    const errorInfo: FormatParseErrorOptions = {\n      cause: {\n        code: 'optionValueInvalid',\n        parameterMap: {\n          propertyName: 'pattern',\n          propertyValue: format\n        }\n      }\n    };\n    const error = new (SyntaxError as any)(msg, errorInfo);\n    throw error;\n  }\n  // parse functions\n  private static _throwWeekdayMismatch(weekday: string, day: number) {\n    const msg = 'The weekday ' + weekday + ' does not match the date ' + day;\n    const errorInfo: FormatParseErrorOptions = {\n      cause: {\n        code: 'dateToWeekdayMismatch',\n        parameterMap: {\n          weekday: weekday,\n          date: day\n        }\n      }\n    };\n    const error = new FormatParseError(msg, errorInfo);\n    throw error;\n  }\n\n  private static _throwDateFormatMismatch(value: string, format: string, style: number) {\n    let msg = '';\n    let errorCodeType = '';\n\n    if (style === 2) {\n      msg =\n        'The value \"' + value + '\" does not match the expected date-time format \"' + format + '\"';\n      errorCodeType = 'datetimeFormatMismatch';\n    } else if (style === 0) {\n      msg = 'The value \"' + value + '\" does not match the expected date format \"' + format + '\"';\n      errorCodeType = 'dateFormatMismatch';\n    } else {\n      msg = 'The value \"' + value + '\" does not match the expected time format \"' + format + '\"';\n      errorCodeType = 'timeFormatMismatch';\n    }\n\n    const errorInfo: FormatParseErrorOptions = {\n      cause: {\n        code: errorCodeType,\n        parameterMap: {\n          value: value,\n          format: format\n        }\n      }\n    };\n    const error = new FormatParseError(msg, errorInfo);\n    throw error;\n  }\n\n  private static _parseTimezoneOffset(_offset: string): Array<number> {\n    const parts: Array<string> = _offset.split(':');\n    const offsetParts = new Array<number>(2);\n\n    // offset is +hh:mm\n    if (parts.length === 2) {\n      offsetParts[0] = parseInt(parts[0], 10);\n      offsetParts[1] = parseInt(parts[1], 10);\n    } else if (_offset.length === 2 || _offset.length === 3) {\n      // offset is +hh or +h\n      offsetParts[0] = parseInt(_offset, 10);\n      offsetParts[1] = 0;\n    } else {\n      // offset is +hhmm\n      offsetParts[0] = parseInt(_offset.substr(0, 3), 10);\n      offsetParts[1] = parseInt(_offset.substr(3), 10);\n    }\n    return offsetParts;\n  }\n\n  private static _expandYear(start2DigitYear: number, year: number): number {\n    // expands 2-digit year into 4 digits.\n    year = Number(year);\n    if (year < 100) {\n      const ambiguousTwoDigitYear = start2DigitYear % 100;\n      // eslint-disable-next-line no-param-reassign\n      year += Math.floor(start2DigitYear / 100) * 100 + (year < ambiguousTwoDigitYear ? 100 : 0);\n    }\n    return year;\n  }\n\n  private static _arrayIndexOfMonthOrDay(\n    monthsDaysData: any,\n    userInput: string,\n    type: 'months' | 'days'\n  ): number {\n    const trimUserInput = NativeParserImpl.toUpperTrimmedNoPeriod(userInput);\n    const keys = Object.keys(monthsDaysData);\n    for (let i = 0; i < keys.length; i++) {\n      const valueFromData = monthsDaysData[keys[i]];\n      const trimValueFromData = NativeParserImpl.toUpperTrimmedNoPeriod(valueFromData);\n      // first try an exact match.\n      if (trimUserInput === trimValueFromData) {\n        return i;\n      }\n\n      // Test if user input is a number. We don't use parseInt because we want\n      // to make sure trimUserInput is only number lie '5' and not '5abc'\n      if (type === 'months') {\n        const trimUserInputNumber = Number(trimUserInput);\n        // In some locales the month name is something like 1月. Remove the literal\n        // before compare in case the user enters only 1.\n        const numberPartFromData = parseInt(trimValueFromData);\n        if (Number.isInteger(numberPartFromData) && Number.isInteger(trimUserInputNumber)) {\n          if (numberPartFromData === trimUserInputNumber) {\n            return i;\n          }\n        }\n      }\n    }\n    return -1;\n  }\n\n  private static toUpperTrimmedNoPeriod(value: string) {\n    let trimItem = LocalOraI18nUtils.toUpper(value);\n    trimItem = LocalOraI18nUtils.trim(trimItem);\n    // In some locales the short month name ends with '.', remove it in case\n    // the user does not enter the dot at the end of the month name.\n    trimItem = trimItem.replace(/\\.$/, '');\n    return trimItem;\n  }\n\n  private static _getDayIndex(calNode: CalendarNodeType, value: string) {\n    let ret = 0;\n    let days = [];\n    const calDaysFmt = calNode.days.format;\n    const calDaysStdAlone = calNode.days['stand-alone'];\n    days = [\n      calDaysFmt.abbreviated,\n      calDaysFmt.wide,\n      calDaysStdAlone.abbreviated,\n      calDaysStdAlone.wide\n    ];\n    for (let m = 0; m < days.length; m++) {\n      ret = this._arrayIndexOfMonthOrDay(days[m], value, 'days');\n      if (ret !== -1) {\n        return ret;\n      }\n    }\n    return ret;\n  }\n\n  private static _getMonthIndex(calNode: CalendarNodeType, value: string) {\n    let ret = -1;\n    const calMonthsFmt = calNode.months.format;\n    const calMonthsStdAlone = calNode.months['stand-alone'];\n    const months = [\n      calMonthsFmt.wide,\n      calMonthsFmt.abbreviated,\n      calMonthsStdAlone.wide,\n      calMonthsStdAlone.abbreviated\n    ];\n    for (let m = 0; m < months.length; m++) {\n      ret = this._arrayIndexOfMonthOrDay(months[m], value, 'months');\n      if (ret !== -1) {\n        return ret;\n      }\n    }\n    return ret;\n  }\n\n  // converts a format string into a regular expression with groups that\n  // can be used to extract date fields from a date string.\n  // check for a cached parse regex.\n  private static _getParseRegExp(format: string, options: NativeDateTimeResolvedOptions): any {\n    //let re = {};\n    // expand single digit formats, then escape regular expression\n    //  characters.\n    const expFormat = format.replace(NativeDateTimeConstants._ESCAPE_REGEXP, '\\\\\\\\$1');\n    const regexp = ['^'];\n    const groups = [];\n    let index = 0;\n    let quoteCount = 0;\n    // iterate through each date token found.\n    let match = NativeDateTimeConstants._TOKEN_REGEXP.exec(expFormat);\n    while (match !== null) {\n      const preMatch = expFormat.slice(index, match.index);\n      index = NativeDateTimeConstants._TOKEN_REGEXP.lastIndex;\n\n      // don't replace any matches that occur inside a string literal.\n      quoteCount += this._appendPreOrPostMatch(preMatch, regexp);\n      if (quoteCount % 2) {\n        regexp.push(match[0]);\n      } else {\n        // add a regex group for the token.\n        const m = match[0];\n        let add = '';\n        if ((NativeDateTimeConstants._PROPERTIES_MAP as any)[m] !== undefined) {\n          add = (NativeDateTimeConstants._PROPERTIES_MAP as any)[m].regExp;\n        } else {\n          this._throwInvalidDateFormat(format, options, m);\n        }\n        if (add) {\n          regexp.push(add);\n        }\n        groups.push(match[0]);\n      }\n      match = NativeDateTimeConstants._TOKEN_REGEXP.exec(expFormat);\n    }\n    this._appendPreOrPostMatch(expFormat.slice(index), regexp);\n    regexp.push('$');\n\n    // allow whitespace to differ when matching formats.\n    const regexpStr = regexp.join('').replace(/\\s+/g, '\\\\s+');\n    const parseRegExp = {\n      regExp: regexpStr,\n      groups: groups\n    };\n    // cache the regex for this format.\n    //re[format] = parseRegExp;\n    return parseRegExp;\n  }\n\n  private static _getTokenIndex(arr: Array<any>, token: string): number {\n    for (let i = 0; i < arr.length; i++) {\n      if (arr[i][token] !== undefined) {\n        return i;\n      }\n    }\n    return 0;\n  }\n\n  // time lenient parse\n  private static _parseLenienthms(\n    result: Date,\n    timepart: string,\n    format: string,\n    dtype: number,\n    calNode: CalendarNodeType\n  ) {\n    // hour, optional minutes and optional seconds\n    (NativeDateTimeConstants._TIME_REGEXP as any).lastIndex = 0;\n    let hour = 0;\n    let minute = 0;\n    let second = 0;\n    let msec = 0;\n    let idx;\n    let match: any = NativeDateTimeConstants._TIME_REGEXP.exec(timepart);\n    let range: RangeType;\n    if (match === null) {\n      this._throwDateFormatMismatch(timepart, format, dtype);\n    }\n    if (match[1] !== undefined) {\n      hour = parseInt(match[1], 10);\n    }\n    if (match[2] !== undefined) {\n      minute = parseInt(match[2], 10);\n    }\n    if (match[3] !== undefined) {\n      second = parseInt(match[3], 10);\n    }\n    if (match[4] !== undefined) {\n      msec = parseInt(match[4], 10);\n    }\n\n    (NativeDateTimeConstants._TIME_FORMAT_REGEXP as any).lastIndex = 0;\n    match = NativeDateTimeConstants._TIME_FORMAT_REGEXP.exec(format);\n    switch (match[0]) {\n      case 'h':\n        // Hour in am/pm (1-12)\n        if (hour === 12) {\n          hour = 0;\n        }\n        range = {\n          name: 'hour',\n          value: hour,\n          low: 0,\n          high: 11,\n          displayValue: hour,\n          displayLow: 1,\n          displayHigh: 12\n        };\n        this._validateRange(range);\n        idx = this._matchPMSymbol(calNode, timepart);\n        if (idx && hour < 12) {\n          hour += 12;\n        }\n        break;\n      case 'K':\n        // Hour in am/pm (0-11)\n        range = {\n          name: 'hour',\n          value: hour,\n          low: 0,\n          high: 11,\n          displayValue: hour,\n          displayLow: 0,\n          displayHigh: 11\n        };\n        this._validateRange(range);\n        idx = this._matchPMSymbol(calNode, timepart);\n        if (idx && hour < 12) {\n          hour += 12;\n        }\n        break;\n      case 'H':\n        range = {\n          name: 'hour',\n          value: hour,\n          low: 0,\n          high: 23,\n          displayValue: hour,\n          displayLow: 0,\n          displayHigh: 23\n        };\n        this._validateRange(range);\n        break;\n      case 'k':\n        if (hour === 24) {\n          hour = 0;\n        }\n        range = {\n          name: 'hour',\n          value: hour,\n          low: 0,\n          high: 23,\n          displayValue: hour,\n          displayLow: 1,\n          displayHigh: 24\n        };\n        break;\n      default:\n        break;\n    }\n    // Minutes.\n    range = {\n      name: 'minute',\n      value: minute,\n      low: 0,\n      high: 59,\n      displayValue: minute,\n      displayLow: 0,\n      displayHigh: 59\n    };\n    this._validateRange(range);\n    // Seconds.\n    range = {\n      name: 'second',\n      value: second,\n      low: 0,\n      high: 59,\n      displayValue: second,\n      displayLow: 0,\n      displayHigh: 59\n    };\n    this._validateRange(range);\n    // millisec\n    range = {\n      name: 'farctionalSecond',\n      value: msec,\n      low: 0,\n      high: 999,\n      displayValue: msec,\n      displayLow: 0,\n      displayHigh: 999\n    };\n    this._validateRange(range);\n    result.setHours(hour, minute, second, msec);\n  }\n\n  private static _getWeekdayName(value: string, calNode: CalendarNodeType): string | null {\n    const calDaysFmt = calNode.days.format;\n    const calDaysStandAlone = calNode.days['stand-alone'];\n    const days = [\n      calDaysFmt.wide,\n      calDaysFmt.abbreviated,\n      calDaysStandAlone.wide,\n      calDaysStandAlone.abbreviated\n    ];\n\n    for (let i = 0; i < days.length; i++) {\n      const dayKeys = Object.keys(days[i]);\n      for (let j = 0; j < dayKeys.length; j++) {\n        const dName = (days as any)[i][dayKeys[j]];\n        const dRegExp = new RegExp(dName + '\\\\b', 'i');\n        if (dRegExp.test(value)) {\n          return dName;\n        }\n      }\n    }\n    return null;\n  }\n\n  // lenient parse yMd and yMEd patterm. Must have year, moth,\n  // date all numbers. Ex: 5/3/2013\n  // weekday is optional. If present it must match date.\n  // Ex:  Tuesday 11/19/2013\n  // if year is 3-digits it can be anywhere in the string.\n  // Otherwise assume its position based on pattern\n  // if date > 12 it can be anywhere in the string.\n  // Otherwise assume its position based on pattern\n  // separators can be any non digit characters\n  private static _parseLenientyMEd(\n    value: string,\n    format: string,\n    options: NativeDateTimeResolvedOptions,\n    cal: any,\n    isDateTime: boolean\n  ): ParsedObjectType {\n    (NativeDateTimeConstants._YMD_REGEXP as any).lastIndex = 0;\n    const match: any = NativeDateTimeConstants._YMD_REGEXP.exec(value);\n    let dtype = 0;\n    if (match === null) {\n      dtype = isDateTime ? 2 : 0;\n      this._throwDateFormatMismatch(value, format, dtype);\n    }\n    const tokenIndexes = [\n      {\n        y: format.indexOf('y')\n      },\n      {\n        M: format.indexOf('M')\n      },\n      {\n        d: format.indexOf('d')\n      }\n    ];\n    tokenIndexes.sort(function (a, b) {\n      const n1 = Object.keys(a)[0];\n      const n2 = Object.keys(b)[0];\n      return (a as any)[n1] - (b as any)[n2];\n    });\n    let year = 0;\n    let month = 0;\n    let day = 0;\n    let yearIndex = 0;\n    let foundDayIndex = 0;\n    let i = 0;\n    const dayIndex = this._getTokenIndex(tokenIndexes, 'd');\n    let foundYear = false;\n    let foundDay = false;\n\n    for (i = 1; i <= 3; i++) {\n      const tokenMatch: string = match[i];\n      // find year if year is yyy|yyyy\n      const intToken = parseInt(tokenMatch);\n      if (tokenMatch.length > 2 || intToken > 31) {\n        year = intToken;\n        foundYear = true;\n        yearIndex = i - 1;\n      }\n    }\n    if (!foundYear) {\n      yearIndex = this._getTokenIndex(tokenIndexes, 'y');\n      year = match[this._getTokenIndex(tokenIndexes, 'y') + 1];\n    }\n    // find day if day value > 12\n    for (i = 0; i < 3; i++) {\n      if (i !== yearIndex && match[i + 1] > 12) {\n        day = match[i + 1];\n        foundDay = true;\n        foundDayIndex = i;\n        break;\n      }\n    }\n    if (!foundDay) {\n      if (yearIndex === this._getTokenIndex(tokenIndexes, 'd')) {\n        day = match[this._getTokenIndex(tokenIndexes, 'y') + 1];\n        month = match[this._getTokenIndex(tokenIndexes, 'M') + 1];\n      } else if (yearIndex === this._getTokenIndex(tokenIndexes, 'M')) {\n        day = match[this._getTokenIndex(tokenIndexes, 'd') + 1];\n        month = match[this._getTokenIndex(tokenIndexes, 'y') + 1];\n      } else {\n        day = match[this._getTokenIndex(tokenIndexes, 'd') + 1];\n        month = match[this._getTokenIndex(tokenIndexes, 'M') + 1];\n      }\n    } else {\n      for (i = 0; i < 3; i++) {\n        if (i !== foundDayIndex && i !== yearIndex) {\n          month = match[i + 1];\n          break;\n        }\n      }\n      if (month === undefined) {\n        month = match[this._getTokenIndex(tokenIndexes, 'M') + 1];\n      }\n    }\n    month -= 1;\n    const daysInMonth = LocalOraI18nUtils.getDaysInMonth(year, month);\n    let range: RangeType;\n    // if both month and day > 12 and swapped, throw exception\n    // based on original order\n    if (foundDay && dayIndex !== foundDayIndex && month > 12) {\n      range = {\n        name: 'month',\n        value: day,\n        low: 0,\n        high: 11,\n        displayValue: day,\n        displayLow: 1,\n        displayHigh: 12\n      };\n      this._validateRange(range);\n    }\n    range = {\n      name: 'month',\n      value: month,\n      low: 0,\n      high: 11,\n      displayValue: month + 1,\n      displayLow: 1,\n      displayHigh: 12\n    };\n    this._validateRange(range);\n    range = {\n      name: 'day',\n      value: day,\n      low: 1,\n      high: daysInMonth,\n      displayValue: day,\n      displayLow: 1,\n      displayHigh: daysInMonth\n    };\n    this._validateRange(range);\n    const start2DigitYear = options.twoDigitYearStart || 1950;\n    year = this._expandYear(start2DigitYear, year);\n    range = {\n      name: 'year',\n      value: year,\n      low: 0,\n      high: 9999,\n      displayValue: year,\n      displayLow: 0,\n      displayHigh: 9999\n    };\n    this._validateRange(range);\n    const parsedDate = new Date(year, month, day);\n    // locate weekday\n    const dName = this._getWeekdayName(value, cal);\n    if (dName !== null) {\n      const weekDay = this._getDayIndex(cal, dName);\n      // day of week does not match date\n      if (parsedDate.getDay() !== weekDay) {\n        this._throwWeekdayMismatch(dName, parsedDate.getDate());\n      }\n    }\n    if (isDateTime) {\n      const timepart = value.substr(NativeDateTimeConstants._YMD_REGEXP.lastIndex);\n      if (timepart.length === 0) {\n        parsedDate.setHours(0, 0, 0, 0);\n      } else {\n        this._parseLenienthms(parsedDate, timepart, format, 2, cal);\n      }\n    }\n    const result: ParsedObjectType = {\n      value: LocalOraI18nUtils.dateToLocalIso(parsedDate),\n      warning: 'lenient parsing was used'\n    };\n    return result;\n  }\n\n  // lenient parse yMMMd and yMMMEd patterns. Must have year, date as numbers\n  // and month name.\n  // weekday is optional. If present it must match date.\n  // Ex:  Monday Nov, 11 2013\n  // weekday and month name can be anywhere in the string.\n  // if year > 2-digits it can be anywhere in the string.\n  // Otherwise assume its position based on pattern\n  // separators can be any non digit characters\n  private static _parseLenientyMMMEd(\n    value: string,\n    format: string,\n    options: NativeDateTimeResolvedOptions,\n    cal: any,\n    isDateTime: boolean\n  ): ParsedObjectType {\n    const origValue = value;\n    // eslint-disable-next-line no-param-reassign\n    value = LocalOraI18nUtils.toUpper(value);\n    // locate month name\n    const calMonthsFmt = cal.months.format;\n    const calMonthsStandAlone = cal.months['stand-alone'];\n    const months = [\n      calMonthsFmt.wide,\n      calMonthsFmt.abbreviated,\n      calMonthsStandAlone.wide,\n      calMonthsStandAlone.abbreviated\n    ];\n    let foundMatch = false;\n    let reverseMonth = [];\n    let i = 0;\n    let mName = '';\n    for (i = 0; i < months.length; i++) {\n      reverseMonth = [];\n      const monthKeys = Object.keys(months[i]);\n      let j = 0;\n      for (j = 0; j < monthKeys.length; j++) {\n        mName = LocalOraI18nUtils.toUpper(months[i][monthKeys[j]]);\n        reverseMonth.unshift({\n          idx: j,\n          name: mName\n        });\n      }\n\n      reverseMonth.sort(function (a, b) {\n        return b.idx - a.idx;\n      });\n\n      for (j = 0; j < reverseMonth.length; j++) {\n        mName = reverseMonth[j].name;\n        if (value.indexOf(mName) !== -1) {\n          foundMatch = true;\n          // eslint-disable-next-line no-param-reassign\n          value = value.replace(mName, '');\n          break;\n        }\n      }\n      if (foundMatch) {\n        break;\n      }\n    }\n    // There is no month name. Try yMEd lenient parse.\n    if (!foundMatch) {\n      return this._parseLenientyMEd(origValue, format, options, cal, isDateTime);\n    }\n\n    const month = this._getMonthIndex(cal, mName);\n    let range: RangeType = {\n      name: 'month',\n      value: month,\n      low: 0,\n      high: 11,\n      displayValue: month,\n      displayLow: 1,\n      displayHigh: 12\n    };\n    this._validateRange(range);\n\n    // locate weekday\n    const dName = this._getWeekdayName(origValue, cal);\n    const dRegExp = new RegExp(dName + '\\\\W', 'i');\n    if (dName !== null) {\n      // eslint-disable-next-line no-param-reassign\n      value = value.replace(dRegExp, '');\n    }\n    // find year and date\n    (NativeDateTimeConstants._YEAR_AND_DATE_REGEXP as any).lastIndex = 0;\n    const match: any = NativeDateTimeConstants._YEAR_AND_DATE_REGEXP.exec(value);\n    if (match === null) {\n      const dtype = isDateTime ? 2 : 0;\n      this._throwDateFormatMismatch(origValue, format, dtype);\n    }\n    const tokenIndexes = [\n      {\n        y: format.indexOf('y')\n      },\n      {\n        d: format.indexOf('d')\n      }\n    ];\n\n    tokenIndexes.sort(function (a, b) {\n      const n1 = Object.keys(a)[0];\n      const n2 = Object.keys(b)[0];\n      return (a as any)[n1] - (b as any)[n2];\n    });\n\n    let year = 0;\n    let day = 0;\n    let yearIndex = 0;\n    let foundYear = false;\n    for (i = 1; i <= 2; i++) {\n      const tokenMatch = match[i];\n      // find year if year is yyy|yyyy\n      const intToken = parseInt(tokenMatch);\n      if (tokenMatch.length > 2 || intToken > 31) {\n        year = intToken;\n        foundYear = true;\n        yearIndex = i - 1;\n      }\n    }\n    if (!foundYear) {\n      yearIndex = this._getTokenIndex(tokenIndexes, 'y');\n      year = parseInt(match[this._getTokenIndex(tokenIndexes, 'y') + 1], 10);\n    }\n    if (yearIndex === this._getTokenIndex(tokenIndexes, 'd')) {\n      day = parseInt(match[this._getTokenIndex(tokenIndexes, 'y') + 1], 10);\n    } else {\n      day = parseInt(match[this._getTokenIndex(tokenIndexes, 'd') + 1], 10);\n    }\n\n    const start2DigitYear = options.twoDigitYearStart || 1950;\n    year = this._expandYear(start2DigitYear, year);\n    range = {\n      name: 'year',\n      value: year,\n      low: 0,\n      high: 9999,\n      displayValue: year,\n      displayLow: 0,\n      displayHigh: 9999\n    };\n    this._validateRange(range);\n    const parsedDate = new Date(year, month, day);\n    if (dName !== null) {\n      const weekDay = this._getDayIndex(cal, dName);\n      // day of week does not match date\n      if (parsedDate.getDay() !== weekDay) {\n        this._throwWeekdayMismatch(dName, parsedDate.getDate());\n      }\n    }\n    const daysInMonth = LocalOraI18nUtils.getDaysInMonth(year, month);\n    range = {\n      name: 'day',\n      value: day,\n      low: 1,\n      high: daysInMonth,\n      displayValue: day,\n      displayLow: 1,\n      displayHigh: daysInMonth\n    };\n    this._validateRange(range);\n\n    if (isDateTime) {\n      const timepart = value.substr(NativeDateTimeConstants._YEAR_AND_DATE_REGEXP.lastIndex);\n      if (timepart.length === 0) {\n        parsedDate.setHours(0, 0, 0, 0);\n      } else {\n        this._parseLenienthms(parsedDate, timepart, format, 2, cal);\n      }\n    }\n    const result: ParsedObjectType = {\n      value: LocalOraI18nUtils.dateToLocalIso(parsedDate),\n      warning: 'lenient parsing was used'\n    };\n    return result;\n  }\n\n  private static _parseLenient(\n    value: string,\n    format: string,\n    options: NativeDateTimeResolvedOptions,\n    cal: CalendarNodeType\n  ): ParsedObjectType {\n    const dtStyle = this._dateTimeStyle(options);\n    let result: ParsedObjectType;\n    switch (dtStyle) {\n      case 0:\n        // date style\n        result = this._parseLenientyMMMEd(value, format, options, cal, false);\n        break;\n      case 1:\n        // time style\n        const d = new Date();\n        this._parseLenienthms(d, value, format, 1, cal);\n        const isoStr = LocalOraI18nUtils.dateToLocalIso(d);\n        result = { value: isoStr, warning: 'lenient parsing was used' };\n        break;\n      case 2:\n        // date-time style\n        result = this._parseLenientyMMMEd(value, format, options, cal, true);\n        break;\n      default:\n        result = { value: '', warning: 'lenient parsing was used' };\n        break;\n    }\n    // convert result to gregorian\n    const parts = LocalOraI18nUtils.IsoStrParts(result.value);\n    const gregParts = [parts[0], parts[1], parts[2]];\n    const isoParts = result.value.split('T');\n    result.value =\n      LocalOraI18nUtils.padZeros(gregParts[0], 4) +\n      '-' +\n      LocalOraI18nUtils.padZeros(gregParts[1], 2) +\n      '-' +\n      LocalOraI18nUtils.padZeros(gregParts[2], 2) +\n      'T' +\n      isoParts[1];\n    return result;\n  }\n\n  private static _getNameIndex(\n    calNode: CalendarNodeType,\n    datePart: string,\n    matchGroup: string,\n    mLength: any,\n    style: any,\n    // @ts-ignore\n    matchIndex: number,\n    start1: number,\n    end1: number,\n    start2: string,\n    end2: string,\n    name: string\n  ): number {\n    let index = 0;\n    const monthsFormat = (calNode as any)[datePart][style];\n    if (datePart === 'months') {\n      index = this._getMonthIndex(calNode, matchGroup);\n    } else {\n      index = this._getDayIndex(calNode, matchGroup);\n    }\n    const startName = monthsFormat[mLength][start2];\n    const endName = monthsFormat[mLength][end2];\n    const range = {\n      name: name,\n      value: index,\n      low: start1,\n      high: end1,\n      displayValue: parseInt(matchGroup),\n      displayLow: startName,\n      displayHigh: endName\n    };\n    this._validateRange(range);\n    return index;\n  }\n\n  private static _validateTimePart(\n    matchInt: number,\n    _timeObj: any,\n    objMap: any,\n    timeToken: string\n  ) {\n    const timeObj = _timeObj;\n    timeObj[objMap.timePart] = matchInt;\n    if (timeToken === 'h' || timeToken === 'hh') {\n      if (matchInt === 12) {\n        timeObj[objMap.timePart] = 0;\n      }\n    } else if (timeToken === 'k' || timeToken === 'kk') {\n      timeObj.htoken = timeToken;\n      if (matchInt === 24) {\n        timeObj[objMap.timePart] = 0;\n      }\n    } else if (timeToken === 'K' || timeToken === 'KK') {\n      if (matchInt === 12) {\n        timeObj[objMap.timePart] = 0;\n      }\n    }\n    const range: RangeType = {\n      name: objMap.timePart,\n      value: timeObj[objMap.timePart],\n      low: objMap.start1,\n      high: objMap.end1,\n      displayValue: matchInt,\n      displayLow: objMap.start2,\n      displayHigh: objMap.end2\n    };\n    this._validateRange(range);\n  }\n\n  // test if the pattern/options is date, time or date-time\n  // 0: date, 1:time, 2:date-time\n  private static _dateTimeStyle(resOptions: NativeDateTimeResolvedOptions): number {\n    const isTime =\n      resOptions.hour !== undefined ||\n      resOptions.minute !== undefined ||\n      resOptions.second !== undefined ||\n      resOptions.fractionalSecondDigits !== undefined;\n    const isDate =\n      resOptions.year !== undefined ||\n      resOptions.month !== undefined ||\n      resOptions.day !== undefined ||\n      resOptions.weekday !== undefined;\n    if (isDate && isTime) {\n      return 2;\n    } else if (isTime) {\n      return 1;\n    } else if (isDate) {\n      return 0;\n    }\n    // try predefined style\n    if (resOptions.dateStyle !== undefined && resOptions.timeStyle !== undefined) {\n      return 2;\n    }\n    if (resOptions.timeStyle !== undefined) {\n      return 1;\n    }\n    return 0;\n  }\n\n  // for zh-TW locales the pm symbol can vary depending on the time. We need\n  // to iterate through the pm symbols in order to find a match.\n  private static _matchPMSymbol(cal: CalendarNodeType, matchGroup: string) {\n    const loc = cal.locale;\n    let isPM = false;\n    let i = 0;\n    if (NativeDateTimeConstants._zh_tw_locales.includes(loc)) {\n      const pmSymbols = NativeDateTimeConstants._zh_tw_pm_symbols;\n      for (i = 0; i < pmSymbols.length; i++) {\n        const pmSymbol = pmSymbols[i];\n        if (matchGroup.indexOf(pmSymbol) !== -1) {\n          return true;\n        }\n      }\n    } else {\n      const calPM = cal.dayPeriods.format.wide.pm;\n      isPM = LocalOraI18nUtils.toUpper(matchGroup).indexOf(LocalOraI18nUtils.toUpper(calPM)) !== -1;\n    }\n    return isPM;\n  }\n\n  // exact match parsing for date-time. If it fails, try lenient parse.\n  private static _parseExact(\n    value: string,\n    format: string,\n    resOptions: NativeDateTimeResolvedOptions,\n    cal: CalendarNodeType\n  ): any {\n    // remove spaces from era.\n    const eraPart = cal.eras.eraAbbr['1'];\n    const trimEraPart = LocalOraI18nUtils.trimNumber(eraPart);\n    // eslint-disable-next-line no-param-reassign\n    value = value.replace(eraPart, trimEraPart);\n    const getOption = LocalOraI18nUtils.getGetOption(resOptions, 'NativeDateTimeConverter.parse');\n    const lenientParse = getOption('lenientParse', 'string', ['none', 'full'], 'full');\n    const dtStyle = this._dateTimeStyle(resOptions);\n\n    // convert date formats into regular expressions with groupings.\n    // use the regexp to determine the input format and extract the date\n    //  fields.\n    const parseInfo = this._getParseRegExp(format, resOptions);\n    const match: any = new RegExp(parseInfo.regExp).exec(value);\n    if (match === null) {\n      if (lenientParse === 'full') {\n        return this._parseLenient(value, format, resOptions, cal);\n      }\n      this._throwDateFormatMismatch(value, format, dtStyle);\n    }\n    // found a date format that matches the input.\n    const groups = parseInfo.groups;\n    let year = null;\n    let month: any = null;\n    let date = null;\n    let weekDay = null;\n    let hourOffset = '';\n    let tzID = null;\n    let pmHour = undefined;\n    let weekDayName = '';\n    let range: RangeType;\n    const timeObj = {\n      hour: 0,\n      minute: 0,\n      second: 0,\n      millisec: 0,\n      htoken: ''\n    };\n    const start2DigitYear = resOptions.twoDigitYearStart || 1950;\n    // iterate the format groups to extract and set the date fields.\n    for (let j = 0, jl = groups.length; j < jl; j++) {\n      const matchGroup = match[j + 1];\n      if (matchGroup) {\n        const current = groups[j];\n        const matchInt = parseInt(matchGroup, 10);\n        const currentGroup = (NativeDateTimeConstants._PROPERTIES_MAP as any)[current];\n\n        switch (currentGroup.token) {\n          case 'months':\n            month = this._getNameIndex(\n              cal,\n              currentGroup.token,\n              matchGroup,\n              currentGroup.mLen,\n              currentGroup.style,\n              currentGroup.matchIndex,\n              0,\n              11,\n              '1',\n              '12',\n              'month name'\n            );\n            break;\n          case 'days':\n            weekDayName = matchGroup;\n            weekDay = this._getNameIndex(\n              cal,\n              currentGroup.token,\n              matchGroup,\n              currentGroup.dLen,\n              currentGroup.style,\n              currentGroup.matchIndex,\n              0,\n              6,\n              'sun',\n              'sat',\n              'weekday'\n            );\n            break;\n          case 'time':\n            this._validateTimePart(matchInt, timeObj, currentGroup, current);\n            break;\n          case 'dayOfMonth':\n            date = matchInt;\n            break;\n          case 'monthIndex':\n            // Month.\n            month = matchInt - 1;\n            // try lenient parse for date style only\n            if (month > 11 && lenientParse === 'full') {\n              try {\n                return this._parseLenient(value, format, resOptions, cal);\n              } catch (e) {\n                range = {\n                  name: 'month',\n                  value: month,\n                  low: 0,\n                  high: 11,\n                  displayValue: month + 1,\n                  displayLow: 1,\n                  displayHigh: 12\n                };\n                this._validateRange(range);\n              }\n            }\n            break;\n          case 'year':\n            year = this._expandYear(start2DigitYear, matchInt);\n            break;\n          case 'ampm':\n            pmHour = this._matchPMSymbol(cal, matchGroup);\n            break;\n          case 'tzhm':\n            // Time zone hours minutes: -0800\n            hourOffset = matchGroup.substr(-2);\n            hourOffset = matchGroup.substr(0, 3) + ':' + hourOffset;\n            break;\n          case 'tzhsepm':\n            // Time zone hours minutes: -08:00\n            hourOffset = matchGroup;\n            break;\n          case 'tzh':\n            // Time zone hours minutes: -08\n            hourOffset = matchGroup + ':00';\n            break;\n          case 'tzid':\n            // Time zone ID: America/Los_Angeles\n            tzID = matchGroup;\n            break;\n          default:\n            break;\n        }\n      }\n    }\n    const parsedDate = new Date();\n    if (year === null) {\n      year = parsedDate.getFullYear();\n    }\n    // if day and month are unspecified,the defaults are current\n    // day and month.\n    if (month === null && date === null) {\n      month = parsedDate.getMonth();\n      date = parsedDate.getDate();\n    } else if (date === null) {\n      // if day is unspecified, default 1st day of month.\n      date = 1;\n    }\n    parsedDate.setFullYear(year, month, date);\n    // validate month days\n    const MonthDays = LocalOraI18nUtils.getDaysInMonth(year, month);\n    range = {\n      name: 'day',\n      value: date,\n      low: 1,\n      high: MonthDays,\n      displayValue: date,\n      displayLow: 1,\n      displayHigh: MonthDays\n    };\n    this._validateRange(range);\n    // if pm designator token was found make sure the hours fit the\n    // 24-hour clock.\n    if (pmHour == true && timeObj.hour < 12) {\n      timeObj.hour += 12;\n    }\n    // when hour is 12 AM and hour cycle is h24, set hour to 00\n    if (\n      pmHour == false &&\n      timeObj.hour == 12 &&\n      (timeObj.htoken == 'k' || timeObj.htoken == 'kk')\n    ) {\n      timeObj.hour = 0;\n    }\n\n    const parts = [year, month + 1, date];\n    parts[3] = timeObj.hour;\n    parts[4] = timeObj.minute;\n    parts[5] = timeObj.second;\n    parts[6] = timeObj.millisec;\n    let isoParsedDate = LocalOraI18nUtils.partsToIsoString(parts);\n    if (tzID !== null) {\n      const zoneOffset = this._getTimeZoneOffset(parts, tzID);\n      hourOffset = LocalOraI18nUtils.getTimeStringFromOffset('', zoneOffset, false, true);\n    }\n    if (hourOffset !== '') {\n      isoParsedDate += hourOffset;\n    }\n    // validate year\n    range = {\n      name: 'year',\n      value: year,\n      low: 0,\n      high: 9999,\n      displayValue: year,\n      displayLow: 0,\n      displayHigh: 9999\n    };\n    this._validateRange(range);\n    // validate month\n    range = {\n      name: 'month',\n      value: month,\n      low: 0,\n      high: 11,\n      displayValue: month + 1,\n      displayLow: 1,\n      displayHigh: 12\n    };\n    this._validateRange(range);\n    // validate day range, depending on the month and year\n    const daysInMonth = LocalOraI18nUtils.getDaysInMonth(parts[0], parts[1] - 1);\n    range = {\n      name: 'day',\n      value: parts[2],\n      low: 1,\n      high: daysInMonth,\n      displayValue: parts[2],\n      displayLow: 1,\n      displayHigh: daysInMonth\n    };\n    this._validateRange(range);\n    // day of week does not match date\n    if (weekDay !== null) {\n      const validateDay = LocalOraI18nUtils.isoToLocalDate(isoParsedDate);\n      if (validateDay && validateDay.getDay() !== weekDay) {\n        this._throwWeekdayMismatch(weekDayName, validateDay.getDate());\n      }\n    }\n    const result = { value: isoParsedDate };\n    return result;\n  }\n\n  // test if the isoStr is date, time or date-time\n  // 0: date, 1:time, 2:date-time\n  private static _isoStrDateTimeStyle(isoStr: string): number {\n    const timeIndex = isoStr.indexOf('T');\n    if (timeIndex === -1) {\n      return 0;\n    }\n    if (timeIndex > 0) {\n      return 2;\n    }\n    return 1;\n  }\n\n  /*\n   * Returns the offset of a time zone at a given moment-in-time.\n   *\n   * @param {Object} localeElements - locale data bundle, it also contain the\n   * timezone data.\n   * @param {string} tzName - The IANA time zone name for which we want to get the\n   * offset. If it is the same as the local system's time zone, return the local\n   * system's time zone offset by using Date.getTimezoneOffset() instead of\n   * going through time zone data.\n   * @param {array} parts - An array conataining year, month, day, hour, minute,\n   * second that are used to create The Date object representing the moment-in-time.\n   */\n  private static _getTimeZoneOffset(parts: any, tzName: any) {\n    // if The timeZone in the options is the same as local system's\n    // timezone, use Date.getTimezoneOffset\n    const localTtimeZone = this.getLocalSystemTimeZone();\n    if (localTtimeZone === tzName) {\n      const d = new Date(parts[0], parts[1] - 1, parts[2], parts[3], parts[4], parts[5]);\n      const localOffset = d.getTimezoneOffset();\n      return -localOffset;\n    }\n    const dateParts: DateDef = {\n      year: parts[0],\n      month: parts[1],\n      date: parts[2],\n      hours: parts[3],\n      minutes: parts[4]\n    };\n    const offset = getISODateOffset(dateParts, tzName);\n    return offset;\n  }\n\n  private static _getAdjustedOffset(timezone: any, isoStrInfo: any) {\n    const parts: Array<number> = isoStrInfo.isoStrParts;\n    return this._getTimeZoneOffset(parts, timezone);\n  }\n\n  private static _adjustHours(isoStrInfo: any, options: NativeDateTimeResolvedOptions) {\n    const value: Array<number> = isoStrInfo.isoStrParts;\n    const isoStrFormat = isoStrInfo.format;\n    let origOffset = 0;\n    switch (isoStrFormat) {\n      case NativeDateTimeConstants._OFFSET:\n        const tzParts = this._parseTimezoneOffset(isoStrInfo.timeZone);\n        const hoursOffset = tzParts[0];\n        const minOffset = tzParts[1];\n        origOffset = hoursOffset * 60 + (hoursOffset < 0 ? -minOffset : minOffset);\n        break;\n      case NativeDateTimeConstants._ZULU:\n        origOffset = 0;\n        break;\n      default:\n        break;\n    }\n    let newOffset = this._getAdjustedOffset(options.timeZone, isoStrInfo);\n    newOffset -= origOffset;\n    // target time zone might have switched to dst before orig timezone, or\n    // orig time zone might have switched to dst before target timezone.\n    // Need to get the correct offset at target time zone. This happens when\n    // we are very close to after target or orig time zones switched to dst.\n    const newDate = new Date(value[0], value[1] - 1, value[2], value[3], value[4], value[4]);\n    newDate.setHours(value[3] + ((newOffset / 60) << 0), newOffset % 60);\n    const newDateIso = LocalOraI18nUtils.dateToLocalIso(newDate);\n    const newDateIsoStrInfo = LocalOraI18nUtils.getISOStrFormatInfo(newDateIso);\n    newOffset = this._getAdjustedOffset(options.timeZone, newDateIsoStrInfo);\n    newOffset -= origOffset;\n    // Do the offset math through the Date object.\n    const adjustD = new Date(\n      Date.UTC(value[0], value[1] - 1, value[2], value[3], value[4], value[5])\n    );\n    const adjustedMin = adjustD.getUTCMinutes() + newOffset;\n    // eslint-disable-next-line no-bitwise\n    adjustD.setUTCHours(adjustD.getUTCHours() + ((adjustedMin / 60) << 0), adjustedMin % 60);\n    value[0] = adjustD.getUTCFullYear();\n    value[1] = adjustD.getUTCMonth() + 1;\n    value[2] = adjustD.getUTCDate();\n    value[3] = adjustD.getUTCHours();\n    value[4] = adjustD.getUTCMinutes();\n    value[5] = adjustD.getUTCSeconds();\n  }\n\n  // Returns a time-only, date-only or date-time ISO string based on dtStyle.\n  private static _createISOStrParts(dtStyle: number, d: Array<any>): string {\n    let ms: any = 0;\n    let val = '';\n    switch (dtStyle) {\n      // Date only\n      case 0:\n        val =\n          LocalOraI18nUtils.padZeros(d[0], 4) +\n          '-' +\n          LocalOraI18nUtils.padZeros(d[1], 2) +\n          '-' +\n          LocalOraI18nUtils.padZeros(d[2], 2);\n        break;\n      // Time only\n      case 1:\n        val =\n          'T' +\n          LocalOraI18nUtils.padZeros(d[3], 2) +\n          ':' +\n          LocalOraI18nUtils.padZeros(d[4], 2) +\n          ':' +\n          LocalOraI18nUtils.padZeros(d[5], 2);\n        ms = d[6];\n        if (ms > 0) {\n          val += '.' + LocalOraI18nUtils.trimRightZeros(ms);\n        }\n        break;\n      // Date-Time\n      default:\n        val =\n          LocalOraI18nUtils.padZeros(d[0], 4) +\n          '-' +\n          LocalOraI18nUtils.padZeros(d[1], 2) +\n          '-' +\n          LocalOraI18nUtils.padZeros(d[2], 2) +\n          'T' +\n          LocalOraI18nUtils.padZeros(d[3], 2) +\n          ':' +\n          LocalOraI18nUtils.padZeros(d[4], 2) +\n          ':' +\n          LocalOraI18nUtils.padZeros(d[5], 2);\n        ms = d[6];\n        if (ms > 0) {\n          val += '.' + LocalOraI18nUtils.trimRightZeros(ms);\n        }\n        break;\n    }\n    return val;\n  }\n\n  private static _getParseISOStringOffset(tzName: string, parts: Array<number>): string {\n    const offset = this._getTimeZoneOffset(parts, tzName);\n    return LocalOraI18nUtils.getTimeStringFromOffset('', offset, false, true);\n  }\n\n  private static _createParseISOStringFromDate(\n    dtStyle: number,\n    isoStrInfo: any,\n    options: NativeDateTimeResolvedOptions\n  ): string {\n    const getOption = LocalOraI18nUtils.getGetOption(options, 'NativeDateTimeConverter.parse');\n    const isoFormat = getOption(\n      'isoStrFormat',\n      'string',\n      [\n        NativeDateTimeConstants._ZULU,\n        NativeDateTimeConstants._OFFSET,\n        NativeDateTimeConstants._INVARIANT,\n        NativeDateTimeConstants._LOCAL,\n        NativeDateTimeConstants._AUTO\n      ],\n      NativeDateTimeConstants._AUTO\n    );\n    const parts = isoStrInfo.isoStrParts;\n    const tzName = options.timeZone;\n    let val = this._createISOStrParts(dtStyle, parts);\n    // do not include timezone if date-only\n    if (dtStyle === 0) {\n      return val;\n    }\n    switch (isoFormat) {\n      case NativeDateTimeConstants._OFFSET:\n      case NativeDateTimeConstants._AUTO:\n        val += this._getParseISOStringOffset(tzName, parts);\n        break;\n      case NativeDateTimeConstants._LOCAL:\n        // if iso string is date-time, consider LOCAL as OFFSET\n        if (dtStyle === 2) {\n          val += this._getParseISOStringOffset(tzName, parts);\n        }\n        break;\n      case NativeDateTimeConstants._ZULU:\n        let adjustedMin = 0;\n        adjustedMin = -this._getTimeZoneOffset(parts, tzName);\n        if (adjustedMin !== 0) {\n          // Do the offset math through date object.\n          const adjustD = new Date(\n            Date.UTC(parts[0], parts[1] - 1, parts[2], parts[3], parts[4], parts[5], parts[6])\n          );\n          adjustedMin = adjustD.getUTCMinutes() + adjustedMin;\n          // eslint-disable-next-line no-bitwise\n          adjustD.setUTCHours(adjustD.getUTCHours() + ((adjustedMin / 60) << 0), adjustedMin % 60);\n          parts[0] = adjustD.getUTCFullYear();\n          parts[1] = adjustD.getUTCMonth() + 1;\n          parts[2] = adjustD.getUTCDate();\n          parts[3] = adjustD.getUTCHours();\n          parts[4] = adjustD.getUTCMinutes();\n          parts[5] = adjustD.getUTCSeconds();\n          val = this._createISOStrParts(dtStyle, parts);\n        }\n        val += 'Z';\n        break;\n      default:\n        break;\n    }\n    return val;\n  }\n\n  /*\n   * Returns the current date at the specified timeZone. If timeZone is\n   * null, return current date of the local system.\n   */\n  public static getTimeZoneCurrentDate(tzName: string | null): string {\n    const options: Intl.DateTimeFormatOptions = {\n      year: 'numeric',\n      day: '2-digit',\n      month: '2-digit'\n    };\n    if (tzName) {\n      options.timeZone = tzName;\n    }\n    const cnv = Intl.DateTimeFormat('en-US', options);\n    const fmt = cnv.format(new Date()); // fmt looks something like 03/05/2020\n    const parts = fmt.split('/');\n    const result = parts[2] + '-' + parts[0] + '-' + parts[1];\n    return result;\n  }\n\n  /*\n   * Returns the current offset of the specified timeZone.\n   */\n  public static getTimeZoneCurrentOffset(timezone: string): number {\n    const d = new Date();\n    const isoStr = LocalOraI18nUtils.dateToLocalIso(d);\n    const isoStrInfo: any = LocalOraI18nUtils.getISOStrFormatInfo(isoStr);\n    return this._getAdjustedOffset(timezone, isoStrInfo);\n  }\n\n  /*\n   * Returns the local system's time zone.\n   */\n  public static getLocalSystemTimeZone(): string {\n    if (!localSystemTimeZone) {\n      const intlCnv = new Intl.DateTimeFormat('en-US');\n      localSystemTimeZone = intlCnv.resolvedOptions().timeZone;\n    }\n    return localSystemTimeZone;\n  }\n}\n","/**\n * @license\n * Copyright (c) 2004 %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { CalendarUtils } from './CalendarUtils';\nimport { DateDef } from './ISODateTimezoneOffset';\nimport { FormatParseError } from '../UNSAFE_IntlFormatParse';\nimport { getISODateOffset } from './ISODateTimezoneOffset';\nimport { Logger } from '../utils/UNSAFE_logger';\nimport { NativeDateTimeConstants } from './NativeDateTimeConstants';\nimport { NativeDateTimeOptions } from './NativeDateTimeOptions';\nimport { NativeParserImpl } from './NativeParserImpl';\nimport { NativeDateTimeResolvedOptions } from './NativeDateTimeOptions';\nimport * as LocalOraI18nUtils from './dateTimeUtils';\n\n/**\n * Create an Intl.DateTimeFormat from the options.\n */\nexport const getFormatter = (options: NativeDateTimeOptions) => {\n  return new Intl.DateTimeFormat(options.locale, options);\n};\n\n/**\n * Get the resolved options from the Intl.DateTimeFormat instance, plus any custom options used by our implementation.\n */\nexport const getResolvedOptions = (\n  formatter: Intl.DateTimeFormat,\n  options: NativeDateTimeOptions\n): NativeDateTimeResolvedOptions => {\n  const resOptions = formatter.resolvedOptions();\n  const isoStrFormat = options.isoStrFormat ?? 'auto';\n  const twoDigitYearStart = options.twoDigitYearStart ?? 1950;\n  const lenientParse = options.lenientParse ?? 'full';\n  const patternFromOptions = getPatternFromOptions(formatter, resOptions);\n  return { ...resOptions, isoStrFormat, twoDigitYearStart, lenientParse, patternFromOptions };\n};\n\n/**\n * Create an Intl.DateTimeFormat that can merge in the year in the desired format during the call to 'format'.\n * This is useful if you always want year: 'numeric' for dateStyle: 'short' even if\n * in some locales dateStyle: 'short' yields a 2-digit year. 2-digit years are ambiguous.\n */\nexport const getYearFormatter = (\n  options: NativeDateTimeOptions,\n  resOptions: NativeDateTimeResolvedOptions\n) => {\n  let formatter: Intl.DateTimeFormat | null = null;\n  // Set up the yearFormatter if dateStyle is short and the dateStyleShortYear option is defined.\n  // If we do not add numberingSystem/calendar, then Intl.DateTimeFormat defaults to the locale's\n  // numberingSystem, and that is not what JET uses.\n  if (options.dateStyle === 'short' && options.dateStyleShortYear) {\n    formatter = new Intl.DateTimeFormat(options.locale, {\n      year: options.dateStyleShortYear,\n      numberingSystem: resOptions.numberingSystem,\n      calendar: resOptions.calendar\n    });\n  }\n  return formatter;\n};\n\n/**\n * Merge in the year in the desired format rather than whatever the locale default is for dateStyle: 'short'.\n */\nexport const formatWithYearFormat = (\n  formatInstance: Intl.DateTimeFormat,\n  yearInstance: Intl.DateTimeFormat,\n  value: Date\n) => {\n  // first get the formatted numeric year\n  const yearParts = yearInstance.formatToParts(value);\n  const formattedYear = yearParts.find((part) => part.type === 'year')?.value;\n  // next get the formatToParts of the formatInstance and substitute in formattedYear.\n  const parts = formatInstance.formatToParts(value);\n  return parts.reduce((acc, part) => {\n    if (part.type === 'year') {\n      return acc + (formattedYear ?? part.value);\n    }\n    return acc + part.value;\n  }, '');\n};\n\n/**\n * Formats a date time string based on the given options.\n */\nexport const formatDateTimeWithOptions = (options: NativeDateTimeOptions, value: string) => {\n  const intlFormatter = getFormatter(options);\n  const resOptions = getResolvedOptions(intlFormatter, options);\n  const yearFormatter = getYearFormatter(options, resOptions);\n  return formatDateTime(intlFormatter, yearFormatter, resOptions.timeZone, value);\n};\n\n/**\n * Formats a date time string using Intl.DateTimeFormat.\n */\nexport const formatDateTime = (\n  intlFormatter: Intl.DateTimeFormat,\n  yearFormatter: Intl.DateTimeFormat | null,\n  timeZone: string,\n  value: string\n) => {\n  const isoStr = normalizeIsoString(timeZone, value);\n  const isoStrDate = new Date(isoStr);\n  return yearFormatter\n    ? formatWithYearFormat(intlFormatter, yearFormatter, isoStrDate)\n    : intlFormatter.format(isoStrDate);\n};\n\n/**\n * Parses a string into an iso string based on the given options.\n */\nexport const parseDateTimeWithOptions = (options: NativeDateTimeOptions, str: string) => {\n  const intlFormatter = getFormatter(options);\n  const resOptions = getResolvedOptions(intlFormatter, options);\n  return parseDateTime(options.locale, intlFormatter, resOptions, str);\n};\n\n/**\n * Parses the formatted string, and returns an iso string.\n * @returns an iso string\n * @throws Error if undefined, null, or '' or not an iso string, or if something went wrong in the call to parse.\n */\nexport const parseDateTime = (\n  locale: string,\n  formatter: Intl.DateTimeFormat,\n  resOptions: NativeDateTimeResolvedOptions,\n  str: string\n) => {\n  if (str === undefined || str === null || str === '') {\n    throw new FormatParseError('The parse value cannot be empty.', {\n      cause: { code: 'emptyParseValue' }\n    });\n  }\n  const cal = CalendarUtils.getCalendar(locale, resOptions.calendar);\n  const pattern = getPatternFromOptions(formatter, resOptions);\n  const result = NativeParserImpl.parseImpl(str, pattern, resOptions, cal);\n  const parsed = result.value;\n  if (parsed) {\n    if (result.warning) {\n      Logger.warn('The value ' + str + ' was leniently parsed to represent a date ' + parsed);\n    }\n  }\n  return parsed;\n};\n\n/**\n * Checks if it is a valid iso string.\n * Also fixes up the iso string if needed, i.e. if local and timezone are specified in the options.\n * @param timeZone\n * @param value\n * @returns\n * @throws Error if undefined, null, or '' or if it is an invalid iso string.\n */\nexport const normalizeIsoString = (timeZone: string, value: string) => {\n  if (value === undefined || value === null || value === '') {\n    throw new FormatParseError('The format value cannot be empty.', {\n      cause: { code: 'emptyFormatValue' }\n    });\n  }\n\n  if (value.startsWith('T')) {\n    // Intl Object takes Date object as parameter. new Date() throws an\n    // exception with time only ISO string. Prepend current date to time\n    // only iso string.\n    let curDate = '';\n    if (timeZone) {\n      // if options contain a timeZone, get the current date at this time zone\n      curDate = NativeParserImpl.getTimeZoneCurrentDate(timeZone);\n    } else {\n      // get the current date of the local system\n      curDate = LocalOraI18nUtils.dateToLocalIso(new Date()).split('T')[0];\n    }\n    value = curDate + value;\n  } else if (value.indexOf('T') === -1) {\n    value = value + 'T00:00:00';\n  }\n\n  // test if value is a valid ISO string\n  const exe = LocalOraI18nUtils._ISO_DATE_REGEXP.exec(value);\n  if (!exe) {\n    const e = new FormatParseError('The format value must be a valid iso string.', {\n      cause: { code: 'invalidISOString', parameterMap: { isoStr: value } }\n    });\n    throw e;\n  }\n  // If value is local ISO string and timeZone is specified in options, adjust\n  // offset to avoid time zone conversion from local system's timezone to target timezone\n  if (timeZone) {\n    // Also test if timeZone in the options is the same as local system time zone\n    let islocalTimeZone = false;\n    const localTimeZone = NativeParserImpl.getLocalSystemTimeZone();\n    if (localTimeZone === timeZone) {\n      islocalTimeZone = true;\n    }\n    const timePart = value.substring(value.indexOf('T'));\n    const isLocalValue =\n      timePart.indexOf('Z') === -1 && timePart.indexOf('+') === -1 && timePart.indexOf('-') === -1;\n    if (isLocalValue && !islocalTimeZone) {\n      const parts = LocalOraI18nUtils.IsoStrParts(value);\n      const dateParts: DateDef = {\n        year: parts[0],\n        month: parts[1],\n        date: parts[2],\n        hours: parts[3],\n        minutes: parts[4]\n      };\n      const offset = getISODateOffset(dateParts, timeZone);\n      value = value + LocalOraI18nUtils.getTimeStringFromOffset('', offset, false, true);\n    }\n  }\n  //if ISO string time zone offset is hh, replace it with hh:00 so that new Date() does not fail\n  value = value.replace(/(T.*?[+-]..$)/, '$1:00');\n  return value;\n};\n\nconst getPatternFromOptions = (\n  formatter: Intl.DateTimeFormat,\n  options: NativeDateTimeResolvedOptions\n) => {\n  const isoSTr = '2000-01-02T00:00:00';\n  const date = new Date(isoSTr);\n  let pattern = '';\n  let optVal = '';\n  let token: any = null;\n  let dtokenMap: any = null;\n  let ttokenMap: any = null;\n  let dateStyle = false;\n  let timeStyle = false;\n  if (options.dateStyle !== undefined) {\n    dtokenMap = NativeDateTimeConstants._dateTimeFormats.dateStyle;\n    dtokenMap = dtokenMap[options.dateStyle];\n    dateStyle = true;\n  }\n  if (options.timeStyle !== undefined) {\n    ttokenMap = NativeDateTimeConstants._dateTimeFormats.timeStyle;\n    ttokenMap = ttokenMap[options.timeStyle];\n    timeStyle = true;\n  }\n  const tokenMap = NativeDateTimeConstants._tokenMap;\n  // eslint-disable-next-line array-callback-return\n  formatter.formatToParts(date).map(({ type, value }) => {\n    // TODO: Intl.DateTimeFormatPartType type does not have 'fractionalSecond' even though it is in the api.\n    // so to workaround getting a typescript error, I'm setting as string here.\n    // Fix when the typescript for Intl.DateTimeFormat gets fixed.\n    switch (type as string) {\n      case 'literal':\n        token = value.replace(NativeDateTimeConstants._ALPHA_REGEXP, \"'$1'\");\n        break;\n      case 'dayPeriod':\n        token = 'a';\n        break;\n      case 'hour':\n        if (timeStyle) {\n          token = ttokenMap[type];\n        } else {\n          optVal = (options as any)[type];\n          token = (tokenMap as any)[type][optVal];\n        }\n        let ish12 = options.hour12;\n        if (ish12 === undefined) {\n          ish12 = false;\n        }\n        // take hourCycle into consideration\n        if (options.hourCycle) {\n          token = token.replace(\n            NativeDateTimeConstants._HOUR12_REGEXP,\n            NativeDateTimeConstants._hourCycleMap[options.hourCycle]\n          );\n        }\n        // h12 takes precedence over hourCycle\n        if (ish12 === true) {\n          token = token.replace(NativeDateTimeConstants._HOUR12_REGEXP, 'h');\n        }\n        break;\n      case 'month':\n        // some locales have month as numeric for medium style and some have month\n        // as medium style check the value to get accurate pattern\n        if (dateStyle) {\n          if (isNaN(+value)) {\n            token = dtokenMap.month_m;\n          } else {\n            token = dtokenMap.month_s;\n          }\n        } else {\n          optVal = (options as any)[type];\n          token = (tokenMap as any)[type][optVal];\n        }\n        break;\n      case 'year':\n      case 'day':\n      case 'weekday':\n        if (dateStyle) {\n          token = dtokenMap[type];\n        } else {\n          optVal = (options as any)[type];\n          token = (tokenMap as any)[type][optVal];\n        }\n        break;\n      case 'minute':\n      case 'second':\n      case 'timeZoneName':\n        if (timeStyle) {\n          token = ttokenMap[type];\n        } else {\n          optVal = (options as any)[type];\n          token = (tokenMap as any)[type][optVal];\n        }\n        break;\n      case 'era':\n        optVal = (options as any)[type] || 'short';\n        token = (tokenMap as any)[type][optVal];\n        break;\n      case 'fractionalSecond':\n        token = options.fractionalSecondDigits;\n        token = (tokenMap as any)[type][token];\n        break;\n      default:\n        break;\n    }\n    pattern += token;\n  });\n  return pattern;\n};\n","var _arity =\n/*#__PURE__*/\nrequire(\"./_arity\");\n\nvar _isPlaceholder =\n/*#__PURE__*/\nrequire(\"./_isPlaceholder\");\n/**\n * Internal curryN function.\n *\n * @private\n * @category Function\n * @param {Number} length The arity of the curried function.\n * @param {Array} received An array of arguments received thus far.\n * @param {Function} fn The function to curry.\n * @return {Function} The curried function.\n */\n\n\nfunction _curryN(length, received, fn) {\n  return function () {\n    var combined = [];\n    var argsIdx = 0;\n    var left = length;\n    var combinedIdx = 0;\n\n    while (combinedIdx < received.length || argsIdx < arguments.length) {\n      var result;\n\n      if (combinedIdx < received.length && (!_isPlaceholder(received[combinedIdx]) || argsIdx >= arguments.length)) {\n        result = received[combinedIdx];\n      } else {\n        result = arguments[argsIdx];\n        argsIdx += 1;\n      }\n\n      combined[combinedIdx] = result;\n\n      if (!_isPlaceholder(result)) {\n        left -= 1;\n      }\n\n      combinedIdx += 1;\n    }\n\n    return left <= 0 ? fn.apply(this, combined) : _arity(left, _curryN(length, combined, fn));\n  };\n}\n\nmodule.exports = _curryN;","var _arity =\n/*#__PURE__*/\nrequire(\"./internal/_arity\");\n\nvar _curry1 =\n/*#__PURE__*/\nrequire(\"./internal/_curry1\");\n\nvar _curry2 =\n/*#__PURE__*/\nrequire(\"./internal/_curry2\");\n\nvar _curryN =\n/*#__PURE__*/\nrequire(\"./internal/_curryN\");\n/**\n * Returns a curried equivalent of the provided function, with the specified\n * arity. The curried function has two unusual capabilities. First, its\n * arguments needn't be provided one at a time. If `g` is `R.curryN(3, f)`, the\n * following are equivalent:\n *\n *   - `g(1)(2)(3)`\n *   - `g(1)(2, 3)`\n *   - `g(1, 2)(3)`\n *   - `g(1, 2, 3)`\n *\n * Secondly, the special placeholder value [`R.__`](#__) may be used to specify\n * \"gaps\", allowing partial application of any combination of arguments,\n * regardless of their positions. If `g` is as above and `_` is [`R.__`](#__),\n * the following are equivalent:\n *\n *   - `g(1, 2, 3)`\n *   - `g(_, 2, 3)(1)`\n *   - `g(_, _, 3)(1)(2)`\n *   - `g(_, _, 3)(1, 2)`\n *   - `g(_, 2)(1)(3)`\n *   - `g(_, 2)(1, 3)`\n *   - `g(_, 2)(_, 3)(1)`\n *\n * @func\n * @memberOf R\n * @since v0.5.0\n * @category Function\n * @sig Number -> (* -> a) -> (* -> a)\n * @param {Number} length The arity for the returned function.\n * @param {Function} fn The function to curry.\n * @return {Function} A new, curried function.\n * @see R.curry\n * @example\n *\n *      const sumArgs = (...args) => R.sum(args);\n *\n *      const curriedAddFourNumbers = R.curryN(4, sumArgs);\n *      const f = curriedAddFourNumbers(1, 2);\n *      const g = f(3);\n *      g(4); //=> 10\n */\n\n\nvar curryN =\n/*#__PURE__*/\n_curry2(function curryN(length, fn) {\n  if (length === 1) {\n    return _curry1(fn);\n  }\n\n  return _arity(length, _curryN(length, [], fn));\n});\n\nmodule.exports = curryN;","/**\n * @license\n * Copyright (c) 2004 %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport {\n  formatDateTime,\n  getFormatter,\n  getResolvedOptions,\n  getYearFormatter,\n  parseDateTime\n} from './formatParse';\nimport { NativeDateTimeOptions } from './NativeDateTimeOptions';\nimport curryN from 'ramda/src/curryN';\n\n/**\n * This function is used to retrieve 'format'and 'parse' methods for formatting or parsing date,\n * time, or datetime values according to the provided options. The options may include:\n *\n * Using the standard date, datetime and time format lengths defined by Unicode CLDR; these\n * include the dateStyle and timeStyle properties (full | long | medium | short).\n *\n * Using options defined by the ECMA 402 Specification, including the properties year,\n * month, day, hour, minute, second, weekday, era, timeZoneName, hour12, timeZone.\n *\n * Passing the BCP47Locale is the only required option. If no other options are specified,\n * the default is to use the 'short' format length for the provided locale.\n *\n * Once the function has been called with a set of options, there is no need to call it again unless\n * you want to change the options being used to format and parse, or the locale.\n */\nexport function getFormatParse(options: NativeDateTimeOptions) {\n  const intlFormatter = getFormatter(options);\n  const resolvedOptions = getResolvedOptions(intlFormatter, options);\n  const yearFormatter = getYearFormatter(options, resolvedOptions);\n\n  const curriedFormat = curryN(4, formatDateTime);\n  const format = curriedFormat(intlFormatter, yearFormatter, resolvedOptions.timeZone);\n\n  const curriedParse = curryN(4, parseDateTime);\n  const parse = curriedParse(options.locale, intlFormatter, resolvedOptions);\n\n  return { format, parse, resolvedOptions, formatter: intlFormatter };\n}\n"],"names":["CalendarUtils","static","locale","calendar","date","Date","getDayPeriodsFromFormatToParts","formatter","eraPart","formatToParts","find","value","type","formatterLocale","getFormatterLocale","Intl","DateTimeFormat","hour","hour12","amValue","setHours","format","wide","am","pm","eras","era","start","cal","eraNarrow","eraAbbr","eraName","getEraFromFormatToParts","eraLenArray","eraMap","narrow","short","long","i","length","j","eraLenName","options","year","month","day","eraForLength","eraObj","widthVal","isStandAlone","dates","getMonthFromFormatToParts","formatParts","monthPart","getWeekdayFromFormatToParts","weekdayPart","calMonthFormat","calDayFormat","index","dayIndexVal","_weekdaysFormatMap","weekday","undefined","monthFormat","dayFormat","calMonths","calDays","types","_monthNamesFormatMap","monthDayObjForWidth","_fillMonthAndDays","myMonthObj","Object","assign","myDayObj","myMonthFormatObj","myDayFormatObj","monthsNode","daysNode","dayObjForWidth","myDayStandAloneObj","monthObjForWidth","myMonthStandAloneObj","calendars","dayPeriodsObj","_getDayPeriods","erasObj","_getEras","standAloneMonths","_getStandAloneMonths","standAloneDays","_getStandAloneDays","exceptionLocales","includes","monthsDaysNodeObj","_getFormatMonthAndDays","monthsNodes","daysNodes","dayPeriods","months","days","formatterCache","Map","getISODateOffset","timeZone","d","UTC","hours","minutes","offset","original","asUTC","originalMins","utcMinutes","delta","_getOffset","_applyTimezoneToDate","adjustment","setTime","getTime","_compareDates","formattedUTC","timezone","get","minute","second","hourCycle","set","_getConverter","localDate","localTime","split","trim","parseInt","date1","date2","NativeDateTimeConstants","_YEAR_AND_DATE_REGEXP","_YMD_REGEXP","_TIME_REGEXP","_TIME_FORMAT_REGEXP","_YEAR_REGEXP","_MONTH_REGEXP","_DAY_REGEXP","_WEEK_DAY_REGEXP","_HOUR_REGEXP","_MINUTE_REGEXP","_SECOND_REGEXP","_FRACTIONAL_SECOND_REGEXP","_AMPM_REGEXP","_WORD_REGEXP","_ESCAPE_REGEXP","_TOKEN_REGEXP","_ZULU","_LOCAL","_AUTO","_INVARIANT","_OFFSET","_ALNUM_REGEXP","_NON_DIGIT_REGEXP","_NON_DIGIT_OPT_REGEXP","_STR_REGEXP","_TWO_DIGITS_REGEXP","_THREE_DIGITS_REGEXP","_FOUR_DIGITS_REGEXP","_SLASH_REGEXP","_PROPERTIES_MAP","MMM","token","style","mLen","matchIndex","key","regExp","MMMM","MMMMM","LLL","LLLL","LLLLL","E","dLen","EE","EEE","EEEE","EEEEE","c","cc","ccc","cccc","ccccc","h","timePart","start1","end1","start2","end2","hh","K","KK","H","HH","k","kk","m","mm","s","ss","S","SS","SSS","getPartIdx","dd","M","MM","L","LL","y","yy","yyyy","a","z","v","zz","zzz","zzzz","Z","ZZ","ZZZ","X","XX","XXX","VV","G","GG","GGG","GGGG","GGGGG","FRACTIONAL_SECOND_MAP","_tokenMap","numeric","fractionalSecond","timeZoneName","_dateTimeFormats","dateStyle","full","month_s","month_m","medium","timeStyle","_ALPHA_REGEXP","_HOUR12_REGEXP","_hourCycleMap","h12","h23","h11","h24","_zh_tw_locales","_zh_tw_pm_symbols","regexTrim","regexTrimNumber","regexTrimRightZeros","zeros","_ISO_DATE_REGEXP","_ISO_DATE_ONLY_REGEXP","startsWith","pattern","indexOf","replace","trimRightZeros","trimNumber","toUpper","join","toUpperCase","padZeros","num","isNegative","substr","zeroPad","str","count","left","result","l","_throwInvalidISOStringRange","isoStr","name","displayValue","displayLow","displayHigh","RangeError","cause","code","parameterMap","minValue","maxValue","propertyName","_throwInvalidISOStringSyntax","Error","dateToLocalIso","_date","getFullYear","getMonth","getDate","getHours","getMinutes","getSeconds","getMilliseconds","isLeapYear","getDaysInMonth","IsoStrParts","isoString","test","splitted","tIndex","today","isBC","datetime","slice","dateSplitted","val","nbDays","milliSecSplitted","timeSplitted","tVal","getGetOption","getOptionCaller","property","values","defaultValue","toLowerCase","_toBoolean","String","Number","expectedValues","push","msg","rangeError","errorInfo","errorCode","propertyValue","propertyValueValid","caller","partsToIsoString","parts","isoToLocalDate","setFullYear","_isoToLocalDateIgnoreTimezone","getISOStrFormatInfo","res","dateTime","isoStrParts","exe","exec","isoStrLen","timeZoneLen","substring","getTimeStringFromOffset","prefix","reverseSign","alwaysMinutes","absOffset","Math","abs","floor","sign","localSystemTimeZone","NativeParserImpl","resOptions","dtStyle","parsedIsoStr","isoStrInfo","LocalOraI18nUtils._ISO_DATE_REGEXP","this","_isoStrDateTimeStyle","_dateTimeStyle","_parseExact","LocalOraI18nUtils.getISOStrFormatInfo","_adjustHours","_createParseISOStringFromDate","warning","isoStrFormat","preMatch","strings","quoteCount","escaped","il","charAt","range","low","high","isDate","isTime","samplePattern","SyntaxError","FormatParseError","errorCodeType","_offset","offsetParts","Array","start2DigitYear","ambiguousTwoDigitYear","monthsDaysData","userInput","trimUserInput","toUpperTrimmedNoPeriod","keys","valueFromData","trimValueFromData","trimUserInputNumber","numberPartFromData","isInteger","trimItem","LocalOraI18nUtils.toUpper","LocalOraI18nUtils.trim","calNode","ret","calDaysFmt","calDaysStdAlone","abbreviated","_arrayIndexOfMonthOrDay","calMonthsFmt","calMonthsStdAlone","expFormat","regexp","groups","match","lastIndex","_appendPreOrPostMatch","add","_throwInvalidDateFormat","arr","timepart","dtype","idx","msec","_throwDateFormatMismatch","_validateRange","_matchPMSymbol","calDaysStandAlone","dayKeys","dName","RegExp","isDateTime","tokenIndexes","sort","b","n1","n2","yearIndex","foundDayIndex","dayIndex","_getTokenIndex","foundYear","foundDay","tokenMatch","intToken","daysInMonth","LocalOraI18nUtils.getDaysInMonth","twoDigitYearStart","_expandYear","parsedDate","_getWeekdayName","weekDay","_getDayIndex","getDay","_throwWeekdayMismatch","_parseLenienthms","LocalOraI18nUtils.dateToLocalIso","origValue","calMonthsStandAlone","foundMatch","reverseMonth","mName","monthKeys","unshift","_parseLenientyMEd","_getMonthIndex","dRegExp","_parseLenientyMMMEd","LocalOraI18nUtils.IsoStrParts","gregParts","isoParts","LocalOraI18nUtils.padZeros","datePart","matchGroup","mLength","monthsFormat","startName","endName","matchInt","_timeObj","objMap","timeToken","timeObj","htoken","fractionalSecondDigits","loc","isPM","pmSymbols","pmSymbol","calPM","trimEraPart","LocalOraI18nUtils.trimNumber","lenientParse","LocalOraI18nUtils.getGetOption","getOption","parseInfo","_getParseRegExp","_parseLenient","pmHour","hourOffset","tzID","weekDayName","millisec","jl","current","currentGroup","_getNameIndex","_validateTimePart","e","MonthDays","isoParsedDate","LocalOraI18nUtils.partsToIsoString","LocalOraI18nUtils.getTimeStringFromOffset","_getTimeZoneOffset","validateDay","LocalOraI18nUtils.isoToLocalDate","timeIndex","tzName","getLocalSystemTimeZone","getTimezoneOffset","origOffset","tzParts","_parseTimezoneOffset","hoursOffset","minOffset","newOffset","_getAdjustedOffset","newDate","newDateIsoStrInfo","adjustD","adjustedMin","getUTCMinutes","setUTCHours","getUTCHours","getUTCFullYear","getUTCMonth","getUTCDate","getUTCSeconds","ms","LocalOraI18nUtils.trimRightZeros","isoFormat","_createISOStrParts","_getParseISOStringOffset","intlCnv","resolvedOptions","getFormatter","getResolvedOptions","patternFromOptions","getPatternFromOptions","getYearFormatter","dateStyleShortYear","numberingSystem","formatWithYearFormat","formatInstance","yearInstance","yearParts","formattedYear","part","reduce","acc","formatDateTime","intlFormatter","yearFormatter","normalizeIsoString","isoStrDate","parseDateTime","getCalendar","parseImpl","parsed","Logger","warn","curDate","getTimeZoneCurrentDate","islocalTimeZone","optVal","dtokenMap","ttokenMap","tokenMap","map","ish12","isNaN","_arity","require$$0","_isPlaceholder","require$$1","_curryN_1","_curryN","received","fn","combined","argsIdx","combinedIdx","arguments","apply","_curry1","_curry2","require$$2","require$$3","curryN_1","curryN","curriedFormat","parse","curriedParse"],"mappings":"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"}